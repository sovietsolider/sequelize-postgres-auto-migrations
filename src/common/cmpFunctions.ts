import { QueryTypes } from 'sequelize';
import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { writeToMigrationFile } from './fileGen';
import { table } from 'console';
import { ObjectType } from 'typescript';
import { generateModelsInfo, modelInfoType } from './modelsInfoGen';
import {
    SchemaTableColumn,
    sqlToSeqTypes,
    getColumnsConstraintsSchemaInfo,
    SchemaTableColumnsConstraints,
} from './interfaces';

export function getModelByTableName(sequelize: Sequelize, table_name: string) {
    let res;
    for (const m in sequelize.models) {
        let tableName = sequelize.models[m].getTableName();
        if (typeof tableName === typeof {}) {
            if (
                (sequelize.models[m].getTableName() as { tableName: string })
                    .tableName === table_name
            ) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        } else {
            if (sequelize.models[m].getTableName() === table_name) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        }
        //console.log(sequelize.models[m].getTableName())
    }
    return res;
}

function generateStringToAddTable(
    model: ModelCtor<Model<any, any>> | undefined,
    model_schema: string | undefined,
    table_name: string,
): string {
    console.log('GENERATE STRING SCHEMA NAME');
    let description = model?.getAttributes();
    console.log(description);
    const attrs_to_except = [
        'type',
        'Model',
        'fieldName',
        '_modelAttribute',
        'field',
        '_autoGenerated',
        'values',
    ];
    let res_string = `await queryInterface.createTable("${table_name}",{`;
    for (const attr in description) {
        console.log('ATTR');
        console.log(attr);

        for (const inside_attr in description[attr]) {
            if (inside_attr === 'type') {
                let type_name = description[attr].type.constructor.name; //(description[attr].type as unknown as {option: any, type: string}).type.constructor.name
                if (type_name === 'ARRAY') {
                    let inside_array_data_type = (
                        description[attr].type as unknown as {
                            option: any;
                            type: string;
                        }
                    ).type.constructor.name as string;
                    console.log('TYPE ARRAY');
                    console.log(description[attr].type);
                    if (inside_array_data_type === 'STRING') {
                        let type_length = (
                            (
                                description[attr].type as unknown as {
                                    options: any;
                                    type: string;
                                }
                            ).type as unknown as { _length: any }
                        )._length;
                        res_string += `${attr}: { type: DataType.${type_name}(DataType.STRING(${type_length})), `;
                    } else
                        res_string += `${attr}: { type: DataType.${type_name}(DataType.${inside_array_data_type}), `;
                } else if (type_name === 'ENUM') {
                    console.log('LENGTH');
                    console.log(type_name);
                    res_string += `${attr}: { type: DataType.${type_name}({ values: [`;
                    for (const [i, value] of (
                        description[attr].values as Array<any>
                    ).entries()) {
                        console.log(value);
                        console.log(
                            (description[attr].values as Array<any>).length - 1,
                        );
                        if (
                            i ===
                            (description[attr].values as Array<any>).length - 1
                        ) {
                            res_string += `"${value}"]})`;
                        } else res_string += `"${value}",`;
                    }
                } else {
                    res_string += `${attr}: { type: DataType.${description[attr].type.constructor.name},`;
                }
            }
            if (inside_attr === 'references') {
                let reference = description[attr][inside_attr] as {
                    model: string;
                    key: string;
                };
                res_string += `${inside_attr}: { model: "${reference.model}", key: "${reference.key}"},`;
                continue;
            } else if (
                inside_attr === 'onDelete' ||
                inside_attr === 'onUpdate'
            ) {
                res_string += `${inside_attr}: "${description[attr][inside_attr]}",`;
                continue;
            }
            //console.log("INSIDE ATTRS")
            //console.log(description[attr][inside_attr as keyof object]);
            //console.log(typeof(String(inside_attr)))
            if (!attrs_to_except.includes(inside_attr)) {
                res_string += `${inside_attr}: ${
                    description[attr][inside_attr as keyof object]
                },`;
            }
        }
        res_string += '},';
    }
    res_string += `},{ transaction: t, schema: "${model_schema}"},);`;
    return res_string;
}

export async function generateStringToAddTableBySchemaInfo(
    sequelize: Sequelize,
    schema_tables: Array<any>,
    table_name_to_add: string,
) {
    console.log('ANTIHYPE');
    for (const schema_table of schema_tables) {
        const schema_table_columns: SchemaTableColumn[] = (
            (await sequelize.query(
                `SELECT table_schema, table_name, column_name, data_type, character_maximum_length, column_default, is_nullable, udt_name FROM information_schema.columns WHERE table_schema='${schema_table.table_schema}' AND table_name='${schema_table.table_name}';`,
            )) as unknown as []
        ).at(0) as unknown as SchemaTableColumn[];
        const schema_table_columns_constraints: SchemaTableColumnsConstraints[] =
            (
                await sequelize.query(
                    `${getColumnsConstraintsSchemaInfo(
                        schema_table.table_schema,
                        schema_table.table_name,
                    )}`,
                )
            ).at(0) as unknown as SchemaTableColumnsConstraints[];
        console.log('SCHEMA TABLE');
        console.log(schema_table_columns);
        console.log(schema_table_columns_constraints);
        let res_string = `await queryInterface.createTable("${table_name_to_add}",{`;
        //
        for (const col of schema_table_columns) {
            let column = col as SchemaTableColumn;
            res_string += `${column.column_name}: { type: "${
                sqlToSeqTypes[column.data_type as keyof object]
            }",`;
            //for within constraints
            for (const constraint_column of schema_table_columns_constraints) {
                if (constraint_column.column_name === column.column_name) {
                    if (constraint_column.constraint_type === 'PRIMARY KEY') {
                        res_string += 'primaryKey: true,';
                    }
                    if (constraint_column.constraint_type === 'FOREIGN KEY') {
                        res_string += `references: { model: { tableName: ${constraint_column.foreign_table_name}, schema: ${constraint_column.foreign_table_schema}} key: '${constraint_column.foreign_column_name}'},`;
                    }
                }
            }

            if (
                column.column_default &&
                column.column_default.match('\bnextval.*')
            ) {
                res_string += `autoIncrement: true, `;
            } else {
                res_string += `defaultValue: ${column.column_default}, `;
            }
            if (column.is_nullable === 'YES') {
                res_string += 'allowNull: true, ';
            } else {
                res_string += 'allowNull: false, ';
            }
        }
    }
}

function generateStringToDeleteTable(
    model_schema: string | undefined,
    table_name: string,
) {
    return `await queryInterface.dropTable({ tableName: '${table_name}', tableSchema: '${model_schema}'},{ transaction: t },);`;
}

export function addMissingTablesToDb(
    sequelize: Sequelize,
    schema_tables: Array<any>,
    tables: modelInfoType[],
): { upString: string; downString: string } {
    let upString: string = '';
    let downString: string = '';
    for (const table of tables) {
        console.log(schema_tables.indexOf(table));
        if (
            !schema_tables.find(
                (element) =>
                    element.table_name === table?.table_name &&
                    element.table_schema === table?.table_schema,
            )
        ) {
            console.log('ADDING');
            console.log(table?.table_name);
            let curr_model = getModelByTableName(sequelize, table?.table_name);
            upString += generateStringToAddTable(
                curr_model as ModelCtor<Model<any, any>> | undefined,
                table?.table_schema,
                table?.table_name,
            );

            downString += generateStringToDeleteTable(
                table?.table_schema,
                table?.table_name,
            );
        }
    }
    return { upString, downString };
}
export async function compareTables(
    sequelize: Sequelize,
    pathToMigrationFile: string,
) {
    const schema_info_tables = await sequelize.query(
        "SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema!='pg_catalog' AND table_schema!='information_schema'",
    );
    const schema_tables: Array<any> = schema_info_tables.at(0) as Array<any>;
    const tables: modelInfoType[] = generateModelsInfo(
        sequelize,
    ) as unknown as modelInfoType[];
    console.log(schema_tables);
    console.log(tables);
    let add_strings: { upString: string; downString: string } =
        addMissingTablesToDb(sequelize, schema_tables, tables);
    writeToMigrationFile(pathToMigrationFile, add_strings.upString);
    writeToMigrationFile(pathToMigrationFile, add_strings.downString); // only for tests

    //console.log("TESTING")
    //await generateStringToAddTableBySchemaInfo(schema_tables, "")

    //revert deleting
    for (const schema_table of schema_tables) {
        console.log(schema_table);
        if (
            !tables.find(
                (element) =>
                    element.table_name === schema_table.table_name &&
                    element.table_schema === schema_table.table_schema,
            )
        ) {
            console.log('DELETING');
            //upString
            let stringToDelete = generateStringToDeleteTable(
                schema_table.table_schema,
                schema_table.table_name,
            );
            writeToMigrationFile(pathToMigrationFile, stringToDelete);
            //downString
            let curr_model = getModelByTableName(
                sequelize,
                schema_table.table_name,
            );
            let downString = generateStringToAddTable(
                curr_model as ModelCtor<Model<any, any>> | undefined,
                schema_table.table_schema,
                schema_table.table_name,
            );
            // here should bt generateStringToAddTableBySchemaInfo
        }
    }

    //}
}
