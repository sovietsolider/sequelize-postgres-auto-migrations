import { QueryTypes, col } from 'sequelize';
import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { writeToMigrationFile } from './fileGen';
import { ObjectType } from 'typescript';
import { generateModelsInfo, modelInfoType } from './modelsInfoGen';
import {  sqlToSeqTypes, SchemaTableColumnsConstraints, SchemaColumnType, SchemaColumns } from './interfaces';
import { getTypeByModelAttr } from './queryParsingFun';
import { generateTableInfo } from './modelsInfoGen';

export function getModelByTableName(sequelize: Sequelize, table_name: string, table_schema: string) {
    let res;
    for (const m in sequelize.models) {
        let tableName = sequelize.models[m].getTableName();
        if (typeof tableName === typeof {}) {
            if ((sequelize.models[m].getTableName() as unknown as { tableName: string, tableSchema: string}).tableName === table_name 
            && (sequelize.models[m].getTableName() as unknown as { tableName: string, tableSchema: string }).tableSchema === table_schema) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        } else {
            if (sequelize.models[m].getTableName() === table_name) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        }
        //console.log(sequelize.models[m].getTableName())
    }
    return res;
}

function generateStringToAddTable(model: ModelCtor<Model<any, any>> | undefined, model_schema: string | undefined, table_name: string): string {
    console.log('GENERATE STRING SCHEMA NAME');
    let description = model?.getAttributes();
    const attrs_to_except = ['type', 'Model', 'fieldName', '_modelAttribute', 'field', '_autoGenerated', 'values'];
    let res_string = `await queryInterface.createTable("${table_name}",{`;
    for (const attr in description) {
        //console.log(attr);
        res_string += `${attr}: {`;
        for (const inside_attr in description[attr]) {
            if (inside_attr === 'type') {
                res_string += `${inside_attr}: ${getTypeByModelAttr(description[attr].type)},`;
            }
            if (inside_attr === 'references') {
                let reference = description[attr][inside_attr] as {
                    model: string;
                    key: string;
                };
                res_string += `${inside_attr}: { model: "${reference.model}", key: "${reference.key}"},`;
                continue;
            } else if (inside_attr === 'onDelete' || inside_attr === 'onUpdate') {
                res_string += `${inside_attr}: "${description[attr][inside_attr]}",`;
                continue;
            }
            if (!attrs_to_except.includes(inside_attr)) {
                res_string += `${inside_attr}: ${description[attr][inside_attr as keyof object]},`;
            }
        }
        res_string += '},';
    }
    res_string += `},{ transaction: t, schema: "${model_schema}"},);`;
    return res_string;
}

export async function generateStringToAddTableBySchemaInfo(sequelize: Sequelize, table_schema: string, table_name: string): Promise<string> {
        console.log("GENERATED INFO")
        let attributes: SchemaColumns = await generateTableInfo(sequelize, table_schema, table_name);
        let res_string = `await queryInterface.createTable("${table_name}",{`;
        for(const column in attributes) {
            let options: SchemaColumnType = attributes[column];
            res_string += `${column}: {`
            console.log('COLUMN!')
            console.log(attributes[column])
            ///type checking
            res_string += 'type: '
            if(options.pg_type.match(/\"enum_\.*/)) {  //ENUM TYPE
                res_string += `DataType.ENUM(`
                let enum_values: {enum_range: Array<string>} = (((await sequelize.query(`SELECT enum_range(NULL::${options.pg_type});`)).at(0)) as Array<any>).at(0);
                for(const val of enum_values.enum_range)
                    res_string += `'${val}',`;
                res_string += ')';
                res_string += ','
                console.log(res_string);
            }
            else if(options.column_type === 'ARRAY') { //ARRAY TYPE
                let final_array_type: string = options.pg_type.replace('[]', '') as string;
                console.log("FINAL ARRAY TYPE")
                console.log(final_array_type)
                for(let i=0; i<options.dimension; i++) 
                    res_string += `DataType.ARRAY(`
                if(sqlToSeqTypes[final_array_type] === 'DataType.STRING')
                    res_string += `DataType.STRING(${options.pg_max_length})`;
                else
                    res_string += `${sqlToSeqTypes[final_array_type]}`;
                for(let i=0; i<options.dimension; i++) {
                    res_string += ')';
                }
                res_string += ','
            }
            else if(options.column_type === 'character varying') 
                res_string += `DataType.STRING(${options.max_length}),`
            else
                res_string += `${sqlToSeqTypes[options.column_type]},`;
            ////
        
            
            if (options.default_value && options.default_value.match(/\bnextval.*/)) {//AUTO INCREMENT 
                res_string += `autoIncrement: true, `;
                console.log("INCREMENT_MATCH")
                console.log(options.default_value)}
            else if(options.default_value)
                res_string += `defaultValue: ${options.default_value}, `;
            

            if (options.is_nullable === 'YES') 
                res_string += 'allowNull: true, ';
            else 
                res_string += 'allowNull: false, ';

            if(options.constraint_type && options.constraint_type === 'PRIMARY KEY')               //CONSTRAINTS 
                res_string += 'primaryKey: true,'
            else if(options.constraint_type && options.constraint_type === 'FOREIGN KEY') 
                res_string += `references: { model: { tableName: '${options.foreign_table_name}', schema: '${options.foreign_table_schema}', key: '${options.foreign_table_name}'},`
            res_string += '},'
        }
        res_string += `},{ transaction: t, schema: "${table_schema}"},);`;
        return Promise.resolve(res_string);
}

function generateStringToDeleteTable(model_schema: string | undefined, table_name: string) {
    return `await queryInterface.dropTable({ tableName: '${table_name}', tableSchema: '${model_schema}'},{ transaction: t },);`;
}

export function addMissingTablesToDb(sequelize: Sequelize, schema_tables: Array<any>, tables: modelInfoType[]): { upString: string; downString: string } {
    let upString: string = '';
    let downString: string = '';
    for (const table of tables) {
        //console.log(schema_tables.indexOf(table));
        if (!schema_tables.find((element) => element.table_name === table?.table_name && element.table_schema === table?.table_schema)) {
            //console.log('ADDING');
            //console.log(table?.table_name);
            let curr_model = getModelByTableName(sequelize, table?.table_name, table?.table_schema);
            upString += generateStringToAddTable(curr_model as ModelCtor<Model<any, any>> | undefined, table?.table_schema, table?.table_name);
            downString += generateStringToDeleteTable(table?.table_schema, table?.table_name);
        }
    }
    return { upString, downString };
}

export async function deleteMissingTablesFromDb(sequelize: Sequelize, schema_tables: Array<any>, tables: modelInfoType[]): Promise<{ upString: string; downString: string }> {
    let upString: string = '';
    let downString: string = '';
    console.log(schema_tables);
    console.log(tables)
    for (const schema_table of schema_tables) {
        if (!tables.find((element) => element.table_name === schema_table.table_name && element.table_schema === schema_table.table_schema)) {
            console.log('DELETING');
            //upString
            upString += generateStringToDeleteTable(schema_table.table_schema, schema_table.table_name);
            //downString
            downString += await generateStringToAddTableBySchemaInfo(sequelize, schema_table.table_schema, schema_table.table_name);
        }
    }
    return Promise.resolve({ upString, downString });
}

export async function compareTables(sequelize: Sequelize, pathToMigrationFile: string) {
    const schema_info_tables = await sequelize.query("SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema!='pg_catalog' AND table_schema!='information_schema'");
    const schema_tables: Array<any> = schema_info_tables.at(0) as Array<any>;
    const tables: modelInfoType[] = generateModelsInfo(sequelize) as unknown as modelInfoType[];
    //console.log(schema_tables);
    //console.log(tables);
    let add_strings: { upString: string; downString: string } = addMissingTablesToDb(sequelize, schema_tables, tables);
    writeToMigrationFile(pathToMigrationFile, add_strings.upString);
    
    let delete_string: { upString: string; downString: string } = await deleteMissingTablesFromDb(sequelize, schema_tables, tables);
    writeToMigrationFile(pathToMigrationFile, delete_string.upString);
    writeToMigrationFile(pathToMigrationFile, '});},')
    writeToMigrationFile(pathToMigrationFile, 'down: async (queryInterface, Sequelize) => {await queryInterface.sequelize.transaction(async (t) => {')
    writeToMigrationFile(pathToMigrationFile, add_strings.downString);
    writeToMigrationFile(pathToMigrationFile, delete_string.downString);
    writeToMigrationFile(pathToMigrationFile, '});},};')
}
