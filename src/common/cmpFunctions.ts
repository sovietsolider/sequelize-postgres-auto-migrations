import { QueryTypes } from "sequelize";
import { Sequelize, Model, ModelCtor } from "sequelize-typescript";
import { writeToMigrationFile } from "./fileGen";
import { table } from "console";
import { ObjectType } from "typescript";
import { generateModelsInfo, modelInfoType } from "./modelsInfoGen";
import { SchemaTableColumn, sqlToSeqTypes, getColumnsConstraintsSchemaInfo, SchemaTableColumnsConstraints } from "./interfaces";

export function getModelByTableName(sequelize: Sequelize, table_name: string) {

    let res;
    for(const m in sequelize.models) {
        let tableName = sequelize.models[m].getTableName();
        if(typeof(tableName) === typeof({})) {
            if((sequelize.models[m].getTableName() as { tableName: string }).tableName === table_name) {
                console.log("EQUALS!")
                res = sequelize.models[m];
            }
        }
        else {
            if(sequelize.models[m].getTableName() === table_name) {
                console.log("EQUALS!")
                res = sequelize.models[m];
            }
        }
        //console.log(sequelize.models[m].getTableName())
    }
    return res;
}

function generateStringToAddTable(model: ModelCtor<Model<any, any>> | undefined, model_schema: string | undefined, table_name: string): string {
    console.log("GENERATE STRING SCHEMA NAME")
    let description = model?.getAttributes();
    console.log(description)
    const attrs_to_except = ["type", "Model", "fieldName", "_modelAttribute", "field", "_autoGenerated", "values"]
    let res_string = `await queryInterface.createTable("${table_name}",{`;
    for(const attr in description) {
        console.log("ATTR")
        console.log(attr)
        
        for(const inside_attr in description[attr]) {
            if(inside_attr === "type") {
                let type_name = description[attr].type.constructor.name; //(description[attr].type as unknown as {option: any, type: string}).type.constructor.name
                if(type_name === "ARRAY") {
                    let inside_array_data_type = (description[attr].type as unknown as {option: any, type: string}).type.constructor.name as string;
                    console.log("TYPE ARRAY")
                    console.log(description[attr].type)
                    if(inside_array_data_type === "STRING") { 
                        let type_length = ((description[attr].type as unknown as {options:any, type:string }).type as unknown as {_length: any})._length
                        res_string += `${attr}: { type: DataType.${type_name}(DataType.STRING(${type_length})), `;
                    }
                    else
                        res_string += `${attr}: { type: DataType.${type_name}(DataType.${inside_array_data_type}), `;
                }
                else if(type_name === "ENUM") {
                    console.log("LENGTH")
                    console.log(type_name)
                    res_string += `${attr}: { type: DataType.${type_name}({ values: [`;
                    for(const [i,value] of (description[attr].values as Array<any>).entries()) {
                        console.log(value)
                        console.log((description[attr].values as Array<any>).length - 1)
                        if (i === (description[attr].values as Array<any>).length - 1) {
                            res_string += `"${value}"]})`;
                        }
                        else
                            res_string += `"${value}",`;
                    }
                }
                else {
                    res_string += `${attr}: { type: DataType.${description[attr].type.constructor.name},`;
                }
            }
            if(inside_attr === "references") {
                let reference = description[attr][inside_attr] as {model: string, key: string};;
                res_string += `${inside_attr}: { model: "${reference.model}", key: "${reference.key}"},`
                continue
            }
            else if(inside_attr === "onDelete" || inside_attr === "onUpdate") {
                res_string += `${inside_attr}: "${description[attr][inside_attr]}",`
                continue
            }
            //console.log("INSIDE ATTRS")
            //console.log(description[attr][inside_attr as keyof object]);
            //console.log(typeof(String(inside_attr)))
            if(!attrs_to_except.includes(inside_attr)) {
                res_string += `${inside_attr}: ${description[attr][inside_attr as keyof object]},`
            }
        }
        res_string += "},"
    }
    res_string += `},{ transaction: t, schema: "${model_schema}"},);`
    return res_string
}

export async function generateStringToAddTableBySchemaInfo(sequelize: Sequelize, schema_tables: Array<any>, table_name_to_add: string) {
    console.log("ANTIHYPE")
    for(const schema_table of schema_tables) {
        const schema_table_columns: SchemaTableColumn[] = ((await sequelize.query(`SELECT table_schema, table_name, column_name, data_type, character_maximum_length, column_default, is_nullable, udt_name FROM information_schema.columns WHERE table_schema='${schema_table.table_schema}' AND table_name='${schema_table.table_name}';`)) as unknown as []).at(0) as unknown as SchemaTableColumn[]
        const schema_table_columns_constraints: SchemaTableColumnsConstraints[] = (await sequelize.query(`${getColumnsConstraintsSchemaInfo(schema_table.table_schema, schema_table.table_name)}`)).at(0) as unknown as SchemaTableColumnsConstraints[];
        console.log("SCHEMA TABLE")
        console.log(schema_table_columns)
        console.log(schema_table_columns_constraints)
        let res_string = `await queryInterface.createTable("${table_name_to_add}",{`;
        //
        for(const col of schema_table_columns) {
            let column = col as SchemaTableColumn;
            res_string += `${column.column_name}: { type: "${sqlToSeqTypes[column.data_type as keyof object]}",`
            //for within constraints
            for(const constraint_column of schema_table_columns_constraints) {
                if(constraint_column.column_name === column.column_name) {
                    if(constraint_column.constraint_type === 'PRIMARY KEY') {
                        res_string += "primaryKey: true,";
                    }
                    if(constraint_column.constraint_type === 'FOREIGN KEY') {
                        res_string += `references: { model: { tableName: ${constraint_column.foreign_table_name}, schema: ${constraint_column.foreign_table_schema}} key: '${constraint_column.foreign_column_name}'},`
                    }
                }
            }
            
            if(column.column_default && column.column_default.match("\bnextval\.*")) {
                res_string += `autoIncrement: true, `
            }
            else {
                res_string += `defaultValue: ${column.column_default}, `
            }
            if(column.is_nullable === 'YES') {
                res_string += 'allowNull: true, ';
            }
            else {
                res_string += 'allowNull: false, '
            }
            
        }
    }
}

function generateStringToDeleteTable(model_schema: string | undefined, table_name: string) {
    return `await queryInterface.dropTable({ tableName: '${table_name}', tableSchema: '${model_schema}'},{ transaction: t },);`;
}

export function addMissingTablesToDb(sequelize: Sequelize, schema_tables: Array<any>, tables: modelInfoType[]): { upString: string, downString: string} {
    let upString:string = "";
    let downString:string = "";
    for(const table of tables) {
        console.log(schema_tables.indexOf(table))
        if(!schema_tables.find(element => element.table_name === table?.table_name && element.table_schema === table?.table_schema)) {
            console.log("ADDING")
            console.log(table?.table_name)
            let curr_model = getModelByTableName(sequelize, table?.table_name);
            upString += generateStringToAddTable(curr_model as ModelCtor<Model<any, any>> | undefined, table?.table_schema, table?.table_name)
            
            downString += generateStringToDeleteTable(table?.table_schema, table?.table_name);
        }
    }
    return { upString, downString }
}
export async function compareTables(sequelize: Sequelize, pathToMigrationFile: string) {
    const schema_info_tables = await sequelize.query("SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema!='pg_catalog' AND table_schema!='information_schema'")
    const schema_tables: Array<any> = schema_info_tables.at(0) as Array<any>;
    const tables: modelInfoType[] = generateModelsInfo(sequelize) as unknown as modelInfoType[];
    console.log(schema_tables)
    console.log(tables)
    let add_strings: { upString: string, downString: string} = addMissingTablesToDb(sequelize, schema_tables, tables);
    writeToMigrationFile(pathToMigrationFile, add_strings.upString);
    writeToMigrationFile(pathToMigrationFile, add_strings.downString) // only for tests
    
    //console.log("TESTING")
    //await generateStringToAddTableBySchemaInfo(schema_tables, "")
        
        
        //revert deleting
        for(const schema_table of schema_tables) {
            console.log(schema_table)
            if(!tables.find(element => element.table_name === schema_table.table_name && element.table_schema === schema_table.table_schema)) {
                console.log("DELETING")
                //upString
                let stringToDelete = generateStringToDeleteTable(schema_table.table_schema, schema_table.table_name);
                writeToMigrationFile(pathToMigrationFile, stringToDelete)
                //downString
                let curr_model = getModelByTableName(sequelize, schema_table.table_name);
                let downString = generateStringToAddTable(curr_model as ModelCtor<Model<any, any>> | undefined, schema_table.table_schema, schema_table.table_name)
                // here should bt generateStringToAddTableBySchemaInfo
            }
        }
        
    //}

}