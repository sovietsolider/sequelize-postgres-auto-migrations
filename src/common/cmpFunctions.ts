import { QueryTypes } from 'sequelize';
import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { writeToMigrationFile } from './fileGen';
import { ObjectType } from 'typescript';
import { generateModelsInfo, modelInfoType } from './modelsInfoGen';
import { SchemaTableColumn, sqlToSeqTypes, getColumnsConstraintsSchemaInfo, SchemaTableColumnsConstraints } from './interfaces';
import { getTypeByModelAttr } from './queryParsingFun';

export function getModelByTableName(sequelize: Sequelize, table_name: string) {
    let res;
    for (const m in sequelize.models) {
        let tableName = sequelize.models[m].getTableName();
        if (typeof tableName === typeof {}) {
            if ((sequelize.models[m].getTableName() as { tableName: string }).tableName === table_name) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        } else {
            if (sequelize.models[m].getTableName() === table_name) {
                console.log('EQUALS!');
                res = sequelize.models[m];
            }
        }
        //console.log(sequelize.models[m].getTableName())
    }
    return res;
}

function generateStringToAddTable(model: ModelCtor<Model<any, any>> | undefined, model_schema: string | undefined, table_name: string): string {
    console.log('GENERATE STRING SCHEMA NAME');
    let description = model?.getAttributes();
    console.log(model);
    console.log(description);
    const attrs_to_except = ['type', 'Model', 'fieldName', '_modelAttribute', 'field', '_autoGenerated', 'values'];
    let res_string = `await queryInterface.createTable("${table_name}",{`;
    for (const attr in description) {
        console.log('ATTR');
        console.log(attr);
        res_string += `${attr}: {`;
        for (const inside_attr in description[attr]) {
            if (inside_attr === 'type') {
                res_string += `${inside_attr}: ${getTypeByModelAttr(description[attr].type)},`;
            }
            if (inside_attr === 'references') {
                let reference = description[attr][inside_attr] as {
                    model: string;
                    key: string;
                };
                res_string += `${inside_attr}: { model: "${reference.model}", key: "${reference.key}"},`;
                continue;
            } else if (inside_attr === 'onDelete' || inside_attr === 'onUpdate') {
                res_string += `${inside_attr}: "${description[attr][inside_attr]}",`;
                continue;
            }
            if (!attrs_to_except.includes(inside_attr)) {
                res_string += `${inside_attr}: ${description[attr][inside_attr as keyof object]},`;
            }
        }
        res_string += '},';
    }
    res_string += `},{ transaction: t, schema: "${model_schema}"},);`;
    return res_string;
}

export async function generateStringToAddTableBySchemaInfo(sequelize: Sequelize, schema_tables: Array<any>, table_name_to_add: string) {
    console.log('ANTIHYPE');
    for (const schema_table of schema_tables) {
        const schema_table_columns: SchemaTableColumn[] = (
            (await sequelize.query(
                `SELECT table_schema, table_name, column_name, data_type, character_maximum_length, column_default, is_nullable, udt_name FROM information_schema.columns WHERE table_schema='${schema_table.table_schema}' AND table_name='${schema_table.table_name}';`,
            )) as unknown as []
        ).at(0) as unknown as SchemaTableColumn[];
        const schema_table_columns_constraints: SchemaTableColumnsConstraints[] = (await sequelize.query(`${getColumnsConstraintsSchemaInfo(schema_table.table_schema, schema_table.table_name)}`)).at(
            0,
        ) as unknown as SchemaTableColumnsConstraints[];

        console.log('SCHEMA TABLE');
        console.log(schema_table_columns);
        console.log(schema_table_columns_constraints);
        let res_string = `await queryInterface.createTable("${table_name_to_add}",{`;
        //
        for (const col of schema_table_columns) {
            let column = col as SchemaTableColumn;
            res_string += `${column.column_name}: { type: "${sqlToSeqTypes[column.data_type as keyof object]}",`;
            //for within constraints
            for (const constraint_column of schema_table_columns_constraints) {
                if (constraint_column.column_name === column.column_name) {
                    if (constraint_column.constraint_type === 'PRIMARY KEY') {
                        res_string += 'primaryKey: true,';
                    }
                    if (constraint_column.constraint_type === 'FOREIGN KEY') {
                        res_string += `references: { model: { tableName: ${constraint_column.foreign_table_name}, schema: ${constraint_column.foreign_table_schema}} key: '${constraint_column.foreign_column_name}'},`;
                    }
                }
            }

            if (column.column_default && column.column_default.match('\bnextval.*')) {
                res_string += `autoIncrement: true, `;
            } else {
                res_string += `defaultValue: ${column.column_default}, `;
            }
            if (column.is_nullable === 'YES') {
                res_string += 'allowNull: true, ';
            } else {
                res_string += 'allowNull: false, ';
            }
        }
    }
}

function generateStringToDeleteTable(model_schema: string | undefined, table_name: string) {
    return `await queryInterface.dropTable({ tableName: '${table_name}', tableSchema: '${model_schema}'},{ transaction: t },);`;
}

export function addMissingTablesToDb(sequelize: Sequelize, schema_tables: Array<any>, tables: modelInfoType[]): { upString: string; downString: string } {
    let upString: string = '';
    let downString: string = '';
    for (const table of tables) {
        console.log(schema_tables.indexOf(table));
        if (!schema_tables.find((element) => element.table_name === table?.table_name && element.table_schema === table?.table_schema)) {
            console.log('ADDING');
            console.log(table?.table_name);
            let curr_model = getModelByTableName(sequelize, table?.table_name);
            upString += generateStringToAddTable(curr_model as ModelCtor<Model<any, any>> | undefined, table?.table_schema, table?.table_name);
            downString += generateStringToDeleteTable(table?.table_schema, table?.table_name);
        }
    }
    return { upString, downString };
}

export function deleteMissingTablesFromDb(sequelize: Sequelize, schema_tables: Array<any>, tables: modelInfoType[]): { upString: string; downString: string } {
    for (const schema_table of schema_tables) {
        console.log(schema_table);
        if (!tables.find((element) => element.table_name === schema_table.table_name && element.table_schema === schema_table.table_schema)) {
            console.log('DELETING');
            //upString
            let stringToDelete = generateStringToDeleteTable(schema_table.table_schema, schema_table.table_name);
            //downString
            let curr_model = getModelByTableName(sequelize, schema_table.table_name);
            // here should be generateStringToAddTableBySchemaInfo
        }
    }
    return { upString: '', downString: '' };
}

export async function compareTables(sequelize: Sequelize, pathToMigrationFile: string) {
    const schema_info_tables = await sequelize.query("SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema!='pg_catalog' AND table_schema!='information_schema'");
    const schema_tables: Array<any> = schema_info_tables.at(0) as Array<any>;
    const tables: modelInfoType[] = generateModelsInfo(sequelize) as unknown as modelInfoType[];
    console.log(schema_tables);
    console.log(tables);
    await generateStringToAddTableBySchemaInfo(sequelize, schema_tables, 'Item');

    let add_strings: { upString: string; downString: string } = addMissingTablesToDb(sequelize, schema_tables, tables);
    writeToMigrationFile(pathToMigrationFile, add_strings.upString);
}
