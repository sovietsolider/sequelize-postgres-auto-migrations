import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { SchemaColumns, SchemaColumnType, sqlToSeqTypes } from '../common/interfaces';
import { ModelService } from './model.service';
import { DbService } from './db.service';
export class StringsGeneratorService {
    static getUpStringToAddTable(model: ModelCtor<Model<any, any>> | undefined, model_schema: string | undefined, table_name: string): string {
        console.log('GENERATE STRING SCHEMA NAME');
        let description = model?.getAttributes();
        const attrs_to_except = ['type', 'Model', 'fieldName', '_modelAttribute', 'field', '_autoGenerated', 'values'];
        let res_string = `await queryInterface.createTable("${table_name}",{`;
        for (const attr in description) {
            //console.log(attr);
            res_string += `${attr}: {`;
            for (const inside_attr in description[attr]) {
                if (inside_attr === 'type') {
                    res_string += `${inside_attr}: ${ModelService.getTypeByModelAttr(description[attr].type)},`;
                }
                if (inside_attr === 'references') {
                    let reference = description[attr][inside_attr] as {
                        model: string;
                        key: string;
                    };
                    res_string += `${inside_attr}: { model: "${reference.model}", key: "${reference.key}"},`;
                    continue;
                } else if (inside_attr === 'onDelete' || inside_attr === 'onUpdate') {
                    res_string += `${inside_attr}: "${description[attr][inside_attr]}",`;
                    continue;
                }
                if (!attrs_to_except.includes(inside_attr)) {
                    res_string += `${inside_attr}: ${description[attr][inside_attr as keyof object]},`;
                }
            }
            res_string += '},';
        }
        res_string += `},{ transaction: t, schema: "${model_schema}"},);`;
        return res_string;
    }
    
    static async getDownStringToAddTable(sequelize: Sequelize, table_schema: string, table_name: string): Promise<string> {
        console.log("GENERATED INFO")
        let attributes: SchemaColumns = await DbService.generateTableInfo(sequelize, table_schema, table_name);
        let res_string = `await queryInterface.createTable("${table_name}",{`;
        for(const column in attributes) {
            let options: SchemaColumnType = attributes[column];
            res_string += `${column}: {`
            console.log('COLUMN!')
            console.log(attributes[column])
            ///type checking
            res_string += 'type: '
            if(options.pg_type.match(/\"enum_\.*/)) {  //ENUM TYPE
                res_string += `DataType.ENUM(`
                let enum_values: {enum_range: Array<string>} = (((await sequelize.query(`SELECT enum_range(NULL::${options.pg_type});`)).at(0)) as Array<any>).at(0);
                for(const val of enum_values.enum_range)
                    res_string += `'${val}',`;
                res_string += ')';
                res_string += ','
                console.log(res_string);
            }
            else if(options.column_type === 'ARRAY') { //ARRAY TYPE
                let final_array_type: string = options.pg_type.replace('[]', '') as string;
                console.log("FINAL ARRAY TYPE")
                console.log(final_array_type)
                for(let i=0; i<options.dimension; i++) 
                    res_string += `DataType.ARRAY(`
                if(sqlToSeqTypes[final_array_type] === 'DataType.STRING')
                    res_string += `DataType.STRING(${options.pg_max_length})`;
                else
                    res_string += `${sqlToSeqTypes[final_array_type]}`;
                for(let i=0; i<options.dimension; i++) {
                    res_string += ')';
                }
                res_string += ','
            }
            else if(options.column_type === 'character varying') 
                res_string += `DataType.STRING(${options.max_length}),`
            else
                res_string += `${sqlToSeqTypes[options.column_type]},`;
                ////
            if (options.default_value && options.default_value.match(/\bnextval.*/)) {//AUTO INCREMENT 
                res_string += `autoIncrement: true, `;
                console.log("INCREMENT_MATCH")
                console.log(options.default_value)}
            else if(options.default_value)
                res_string += `defaultValue: ${options.default_value}, `;
            if (options.is_nullable === 'YES') 
                res_string += 'allowNull: true, ';
            else 
                res_string += 'allowNull: false, ';
            if(options.constraint_type && options.constraint_type === 'PRIMARY KEY')               //CONSTRAINTS 
                res_string += 'primaryKey: true,'
            else if(options.constraint_type && options.constraint_type === 'FOREIGN KEY') {
                res_string += `references: { model: { tableName: '${options.foreign_table_name}', schema: '${options.foreign_table_schema}', key: '${options.foreign_table_name}'},`
                let fk_options = await DbService.getForeignKeyOptions(sequelize, options.constraint_name, options.table_schemas);
                console.log("FK OPTIONS")
                console.log(fk_options)
                res_string += `onUpdate: '${fk_options.update_rule}',`
                res_string += `onDelete: '${fk_options.delete_rule}',`
                res_string += '},'
            }
            res_string += '},'
        }
        res_string += `},{ transaction: t, schema: "${table_schema}"},);`;
        return Promise.resolve(res_string);
    }
    
    static getUpStringToDeleteTable(model_schema: string | undefined, table_name: string) {
        return `await queryInterface.dropTable({ tableName: '${table_name}', tableSchema: '${model_schema}'},{ transaction: t },);`;
    }
}