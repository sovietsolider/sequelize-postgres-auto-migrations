import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { DataType, ModelAttributeColumnOptions, WhereOptions } from 'sequelize';
import { TableToModel, ModelAttribute, MigrationOptions } from '../common/interfaces';
import { ModelService } from './model.service';
import { DbService } from './db.service';
import { IndexesOptions } from 'sequelize';

export class StringsGeneratorService {
    private sequelize: Sequelize;
    private dbService: DbService;
    private modelService: ModelService;
    private attrs_to_except = [
        'Model',
        'fieldName',
        '_modelAttribute',
        'field',
        '_autoGenerated',
        'values',
        'unique',
        'primaryKey',
        'name',
        'references',
        'onUpdate',
        'onDelete',
        'defaultValue',
        'pk_name',
        'fk_name',
        'unique_name',
        'get',
        'validate',
        'comment'
    ];
    constructor(_sequelize: Sequelize, dbService: DbService, modelService: ModelService) {
        this.sequelize = _sequelize;
        this.dbService = dbService;
        this.modelService = modelService;
    }
    async getStringsToChangeTable(
        sequelize: Sequelize,
        table_schema: string,
        table_name: string,
        removed_fk: { [x: string]: boolean },
    ): Promise<{
        upString: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string; pk: string; unique: string };
            remove_constraints_string: { fk: string; pk: string; unique: string };
        };
        downString: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string; pk: string; unique: string };
            remove_constraints_string: { fk: string; pk: string; unique: string };
        };
    }> {
        let up_string: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string; pk: string; unique: string };
            remove_constraints_string: { fk: string; pk: string; unique: string };
        } = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' },
        };
        let down_string: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string; pk: string; unique: string };
            remove_constraints_string: { fk: string; pk: string; unique: string };
        } = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' },
        };

        let tableInDb: TableToModel = await this.dbService.tableToModelInfo(
            sequelize,
            table_schema,
            table_name,
        );
        let tableInModel = (
            this.modelService.getModelByTableName(sequelize, table_name, table_schema) as ModelCtor<
                Model<any, any>
            >
        ).getAttributes();
        const model_columns_names = this.modelService.getModelAttributesNames(tableInModel);
        for (const column of model_columns_names) {
            let real_column_name = tableInModel[column].field as string;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                let tmp_up_string = '';
                let tmp_down_string = '';

                //обработка array(enum)
                
                //let raw_type = await this.dbService.getRawType(sequelize, table_schema, table_name, real_column_name);
                if(this.modelService.getTypeByModelAttr(tableInModel[column].type, '').includes('ARRAY') 
                && this.modelService.getTypeByModelAttr(tableInModel[column].type, '').includes('ENUM')) {
                    let model_enum_values: string[] = [];
                    let db_enum_values: string[] = [];
                    //getting enum values
                    this.modelService.getTypeByModelAttr(tableInModel[column].type, '', { enum_values: model_enum_values, raw_type: ''});
                    await this.dbService.tableToModelInfo(sequelize, table_schema, table_name, {enum_values: db_enum_values, column_name: real_column_name});
                    // getting type name
                    let raw_type = this.getRawEnumType(tableInModel, table_name, real_column_name);
                    let type_schema = `"${table_schema}".`;
                    if(type_schema === '"public".')
                        type_schema = '';
                    if(tableInDb[real_column_name].type?.includes('ENUM'))
                        tmp_up_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`
                    tmp_up_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${model_enum_values.join("','")}')\`, {transaction: t});`;
                    tmp_up_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${column}" type ${type_schema}${raw_type} using "${column}"::text::${type_schema}${raw_type};', {transaction: t});`;
                    tmp_up_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;

                    tmp_down_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`
                    tmp_down_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${db_enum_values.join("','")}')\`, {transaction: t});`;
                    tmp_down_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${real_column_name}" type ${raw_type} using "${column}"::text::${raw_type};', {transaction: t});`;
                    tmp_down_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;
                }
                tmp_up_string += `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                tmp_down_string += `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                if(this.modelService.getTypeByModelAttr(tableInModel[column].type, '').includes('ARRAY') 
                && this.modelService.getTypeByModelAttr(tableInModel[column].type, '').includes('ENUM')) {
                    let raw_type = this.getRawEnumType(tableInModel, table_name, real_column_name);
                    tmp_up_string += `type: '${raw_type}',`;
                    tmp_down_string += `type: '${raw_type}',`;
                }
                else if(this.modelService.getTypeByModelAttr(tableInModel[column].type, '') === 'Sequelize.INTEGER'
                && tableInDb[real_column_name].type !== 'Sequelize.INTEGER' ) {
                    tmp_up_string += `type: 'INTEGER USING CAST ("${real_column_name}" as INTEGER)',`
                }
                else {    
                    tmp_up_string += `type: ${this.modelService.getTypeByModelAttr(
                        tableInModel[column].type,
                    )},`;
                    tmp_down_string += `type: ${tableInDb[real_column_name].type},`;
                }
                if (
                    this.modelService.getTypeByModelAttr(tableInModel[column].type) !==
                    tableInDb[real_column_name].type
                ) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined) model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    tmp_up_string += `allowNull: ${model_allow_null},`;
                    tmp_down_string += `allowNull: ${tableInDb[real_column_name].allowNull},`;
                    columns_different = true;
                }
                if (
                    tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement
                ) {
                    tmp_up_string += `autoIncrement: ${tableInModel[column].autoIncrement},`;
                    tmp_down_string += `autoIncrement: ${tableInDb[real_column_name].autoIncrement},`;
                    columns_different = true;
                }
                if (
                    (tableInModel[column].defaultValue + '') !== (tableInDb[real_column_name].defaultValue + '')
                ) {
                    tmp_up_string += `defaultValue: ${JSON.stringify(
                        tableInModel[column].defaultValue,
                    )},`;
                    tmp_down_string += `defaultValue: ${tableInDb[real_column_name].defaultValue},`;

                    columns_different = true;
                }
                //console.log(tableInModel[column].comment, tableInDb[real_column_name].comment);
                if(tableInModel[column].comment !== tableInDb[real_column_name].comment) {
                    if(tableInModel[column].comment)
                        tmp_up_string += `comment: '${tableInModel[column].comment}',`;
                    else
                        tmp_up_string += `comment: ${tableInModel[column].comment},`;
                    if(tableInDb[real_column_name].comment)
                        tmp_down_string += `comment: '${tableInDb[real_column_name].comment}',`;
                    else
                        tmp_down_string += `comment: ${tableInDb[real_column_name].comment},`;
                    columns_different = true;
                }
                if(columns_different && model_allow_null === tableInDb[real_column_name].allowNull) { //sequelize drop allow null
                    tmp_up_string += `allowNull: ${model_allow_null},`;
                    tmp_down_string += `allowNull: ${tableInDb[real_column_name].allowNull},`;
                }

                tmp_up_string += '},{ transaction: t });';
                tmp_down_string += '},{ transaction: t});';
                if (!columns_different) {
                    tmp_up_string = '';
                    tmp_down_string = '';
                } else {
                    up_string.change_column_string += tmp_up_string;
                    down_string.change_column_string += tmp_down_string;
                }
            } else {
                //column is missing in Db -> add
                up_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                up_string.add_column_string += this.modelService.getModelColumnDescriptionAsString(
                    tableInModel,
                    column,
                );
                up_string.add_column_string += `{ transaction: t });`;
                down_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {transaction: t});`;
            }
        }
        //column is missing in Model -> delete
        for (const column in tableInDb) {
            if (!model_columns_names.includes(column)) {
                up_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {transaction: t});`;
                down_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {`;
                for (const column_attr in tableInDb[column]) {
                    if (!this.attrs_to_except.includes(column_attr)) {
                        down_string.add_column_string += `${column_attr}: ${
                            tableInDb[column][column_attr as keyof object]
                        },`;
                    }
                }
                down_string.add_column_string += '},{transaction: t});';
            }
        }
        let constraints_res_strings = await this.getStringToChangeConstraints(
            table_schema,
            table_name,
            tableInModel,
            tableInDb,
            removed_fk,
        );

        up_string.remove_constraints_string.fk +=
            constraints_res_strings.res_up_string.remove_constr_string.fk; //удаление ограничений
        up_string.remove_constraints_string.pk +=
            constraints_res_strings.res_up_string.remove_constr_string.pk;
        up_string.remove_constraints_string.unique +=
            constraints_res_strings.res_up_string.remove_constr_string.unique;
        up_string.add_constraints_string.pk +=
            constraints_res_strings.res_up_string.add_constr_string.pk; //добавление ограничений
        up_string.add_constraints_string.unique +=
            constraints_res_strings.res_up_string.add_constr_string.unique;
        up_string.add_constraints_string.fk +=
            constraints_res_strings.res_up_string.add_constr_string.fk;

        //res_string.down_string += index_strings.down_string.remove_index_string; //удаление индексов
        down_string.remove_constraints_string.fk +=
            constraints_res_strings.res_down_string.remove_constr_string.fk; //удаление ограничений
        down_string.remove_constraints_string.pk +=
            constraints_res_strings.res_down_string.remove_constr_string.pk;
        down_string.remove_constraints_string.unique +=
            constraints_res_strings.res_down_string.remove_constr_string.unique;
        down_string.add_constraints_string.pk +=
            constraints_res_strings.res_down_string.add_constr_string.pk; //добавление ограничений
        down_string.add_constraints_string.unique +=
            constraints_res_strings.res_down_string.add_constr_string.unique;
        down_string.add_constraints_string.fk +=
            constraints_res_strings.res_down_string.add_constr_string.fk;
        return Promise.resolve({
            upString: up_string,
            downString: down_string,
        });
    }

    getRawEnumType(tableInModel: { readonly [x: string]: ModelAttributeColumnOptions<Model<any, any>>;}, table_name: string, column_name: string) {
        let depth_count = this.modelService.getTypeByModelAttr(tableInModel[column_name as keyof ModelCtor<Model<any, any>>].type, '').match(/ARRAY/)?.length as number;
        let raw_type_depth = ''
        for(let i=0; i<depth_count; i++) 
            raw_type_depth += '[]';
        return `"enum_${table_name}_${column_name}"${raw_type_depth}`;
    }

    async getChangedColumns(sequelize: Sequelize, table_schema: string, table_name: string) {
        let tableInDb: TableToModel = await this.dbService.tableToModelInfo(
            sequelize,
            table_schema,
            table_name,
        );
        let tableInModel = (
            this.modelService.getModelByTableName(sequelize, table_name, table_schema) as ModelCtor<
                Model<any, any>
            >
        ).getAttributes();
        let different_columns: string[] = [];
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                if (
                    this.modelService.getTypeByModelAttr(tableInModel[column].type) !==
                    tableInDb[real_column_name].type
                ) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined) model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    columns_different = true;
                }
                if (
                    tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement
                ) {
                    columns_different = true;
                }
                if (
                    tableInModel[column].defaultValue !== tableInDb[real_column_name].defaultValue
                ) {
                    columns_different = true;
                }
                if (columns_different) different_columns.push(column);
            }
        }

        return different_columns;
    }

    private async getStringToChangeConstraints(
        table_schema: string,
        table_name: string,
        tableInModel: {
            readonly [x: string]: ModelAttributeColumnOptions<Model<any, any>>;
        },
        tableInDb: TableToModel,
        removed_fk: { [x: string]: boolean },
    ) {
        let res_up_string: {
            add_constr_string: { pk: string; fk: string; unique: string };
            remove_constr_string: { pk: string; fk: string; unique: string };
        } = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let res_down_string: {
            add_constr_string: { pk: string; fk: string; unique: string };
            remove_constr_string: { pk: string; fk: string; unique: string };
        } = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let pk_model_fields: Array<string> = [];
        let pk_db_fields: Array<string> = [];
        let fk_model_fields: Array<string> = [];
        let fk_db_fields: Array<string> = [];
        let unique_model_fields: Array<string> = [];
        let unique_db_fields: Array<string> = [];
        let changed_columns = await this.getChangedColumns(
            this.sequelize,
            table_schema,
            table_name,
        );
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (tableInModel[column].primaryKey) pk_model_fields.push(real_column_name);
            if (tableInModel[column].references) fk_model_fields.push(real_column_name);
            if (tableInModel[column].unique) unique_model_fields.push(real_column_name);
        }
        for (const column in tableInDb) {
            if (tableInDb[column].primaryKey) pk_db_fields.push(column);
            if (tableInDb[column].foreignKey) fk_db_fields.push(column);
            if (tableInDb[column].unique) unique_db_fields.push(column);
        }
        //PRIMARY KEYS
        if (pk_model_fields.length !== 0 && pk_db_fields.length === 0) {
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', {transaction: t});`;
        } else if (pk_model_fields.length === 0 && pk_db_fields.length !== 0) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${
                tableInDb[pk_db_fields[0]].pk_name
            }', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
        } else if (
            (JSON.stringify(pk_model_fields) !== JSON.stringify(pk_db_fields) ||
                pk_model_fields.some((r) => changed_columns.includes(r))) &&
            pk_model_fields[0]
        ) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${
                tableInDb[pk_db_fields[0]].pk_name
            }', {transaction: t});`;
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
        }

        for (const field of fk_model_fields) {
            //если fk нету в дб -> добавляем
            if (!fk_db_fields.includes(field)) {
                let model_ref = this.modelService.getModelReference(
                    tableInModel[field].references as {
                        model: { tableName: string; schema: string } | string;
                        key: string;
                    },
                );
                res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${
                    model_ref.model.tableName
                }', schema: '${model_ref.model.schema}' },field: '${model_ref.key}',}, onDelete: '${
                    tableInModel[field].onDelete
                }',onUpdate: '${tableInModel[field].onUpdate}', name: '${this.getConstraintName(
                    table_name,
                    table_schema,
                    field,
                    'fkey',
                )}',transaction: t});`;
                res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                    table_name,
                    table_schema,
                    field,
                    'fkey',
                )}', {transaction: t});`;
            } else {
                //console.log(changed_columns.some(r => this.isReferenced(table_name, table_schema, r, this.sequelize.models as { [key: string]: ModelCtor<Model<any, any>>; })))
                if (
                    ((JSON.stringify(
                        this.modelService.getModelReference(
                            tableInModel[field].references as {
                                model: { tableName: string; schema: string } | string;
                                key: string;
                            },
                        ),
                    ) !== JSON.stringify(tableInDb[field].references)) ||
                        tableInModel[field].onDelete?.toLowerCase() !== tableInDb[field].onDelete?.toLowerCase() ||
                        tableInModel[field].onUpdate?.toLowerCase() !== tableInDb[field].onUpdate?.toLowerCase() ||
                        fk_model_fields.some((r) => changed_columns.includes(r))) &&
                    //|| changed_columns.some(r => this.isReferenced(table_name, table_schema, r, this.sequelize.models as { [key: string]: ModelCtor<Model<any, any>>; }))
                    !removed_fk[
                        JSON.stringify({
                            tableName: table_name,
                            schema: table_schema,
                            columnName: field,
                        })
                    ]
                ) {
                    console.log("changing fk")
                    let model_ref = this.modelService.getModelReference(
                        tableInModel[field].references as {
                            model: { tableName: string; schema: string } | string;
                            key: string;
                        },
                    );
                    res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                    res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${
                        model_ref.model.tableName
                    }', schema: '${model_ref.model.schema}' },field: '${
                        model_ref.key
                    }',}, onDelete: '${tableInModel[field].onDelete}',onUpdate: '${
                        tableInModel[field].onUpdate
                    }',name: '${this.getConstraintName(
                        table_name,
                        table_schema,
                        field,
                        'fkey',
                    )}',transaction: t});`;
                    res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                        table_name,
                        table_schema,
                        field,
                        'fkey',
                    )}', {transaction: t});`;
                    res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'], references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}',name: '${tableInDb[field].fk_name}',transaction: t});`;
                }
            }
        }

        for (const field of fk_db_fields) {
            if (!fk_model_fields.includes(field)) {
                //no fk in model -> delete fk from db
                res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}', name: '${tableInDb[field].fk_name}', transaction: t});`;
            }
        }
        //UNIQUE
        this.getStringToCompareUniqueConstraints(
            table_name,
            table_schema,
            tableInModel,
            res_up_string,
            res_down_string,
            tableInDb,
        );
        return Promise.resolve({ res_up_string, res_down_string });
    }

    getStringToCompareUniqueConstraints(
        table_name: string,
        table_schema: string,
        tableInModel: {
            readonly [x: string]: ModelAttributeColumnOptions<Model<any, any>>;
        },
        res_up_string: {
            add_constr_string: {
                pk: string;
                fk: string;
                unique: string;
            };
            remove_constr_string: {
                pk: string;
                fk: string;
                unique: string;
            };
        },
        res_down_string: {
            add_constr_string: {
                pk: string;
                fk: string;
                unique: string;
            };
            remove_constr_string: {
                pk: string;
                fk: string;
                unique: string;
            };
        },
        tableInDb: TableToModel = {},
    ) {
        let model_composite_unique_list: { [key: string]: Array<string> } = {};
        let db_unique_list: { [key: string]: Array<string> } = {};
        let unique_model_fields: Array<string> = [];
        let unique_db_fields: Array<string> = [];
        //if(tableInModel === undefined)
        //    tableInModel = {};
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (tableInModel[column].unique) unique_model_fields.push(real_column_name);
        }
        for (const column in tableInDb) {
            if (tableInDb[column].unique) unique_db_fields.push(column);
        }
        for (const field of unique_model_fields) {
            if (typeof tableInModel[field].unique === typeof {}) {
                if (
                    model_composite_unique_list[
                        (
                            tableInModel[field].unique as unknown as {
                                name: string;
                                msg: string;
                            }
                        ).name
                    ] === undefined
                )
                    model_composite_unique_list[
                        (
                            tableInModel[field].unique as unknown as {
                                name: string;
                                msg: string;
                            }
                        ).name
                    ] = [];
                model_composite_unique_list[
                    (
                        tableInModel[field].unique as unknown as {
                            name: string;
                            msg: string;
                        }
                    ).name
                ].push(field);
            } else if (typeof tableInModel[field].unique === typeof true) {
                if (
                    model_composite_unique_list[
                        this.getConstraintName(table_name, table_schema, field, 'key')
                    ] === undefined
                )
                    model_composite_unique_list[
                        this.getConstraintName(table_name, table_schema, field, 'key')
                    ] = [];
                model_composite_unique_list[
                    this.getConstraintName(table_name, table_schema, field, 'key')
                ].push(field);
            } else if (typeof tableInModel[field].unique === typeof '') {
                if (model_composite_unique_list[tableInModel[field].unique as string] === undefined)
                    model_composite_unique_list[tableInModel[field].unique as string] = [];
                model_composite_unique_list[tableInModel[field].unique as string].push(field);
            }
        }

        let keys_to_delete: Array<string> = [];
        for (const item in model_composite_unique_list) {
            if (
                model_composite_unique_list[item].length > 1 ||
                item !==
                    this.getConstraintName(
                        table_name,
                        table_schema,
                        model_composite_unique_list[item][0],
                        'key',
                    )
            ) {
                let tmp: Array<string> = [];
                for (const field of model_composite_unique_list[item]) {
                    tmp.push(field);
                }
                keys_to_delete.push(item);
                model_composite_unique_list[
                    this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')
                ] = [];
                for (const i of tmp) {
                    model_composite_unique_list[
                        this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')
                    ].push(i);
                }
            }
        }
        for (const i of keys_to_delete) delete model_composite_unique_list[i];

        for (const field of unique_db_fields) {
            if (db_unique_list[tableInDb[field].unique_name as string] === undefined)
                db_unique_list[tableInDb[field].unique_name as string] = [];
            db_unique_list[tableInDb[field].unique_name as string].push(field);
        }
        for (const constr_name in model_composite_unique_list) {
            if (!Object.keys(db_unique_list).includes(constr_name)) {
                //db doesnt have this unique -> add
                res_up_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${model_composite_unique_list[
                    constr_name
                ].join("','")}'],type: 'UNIQUE',name: '${this.getConstraintNameOfCompositeKey(
                    table_name,
                    table_schema,
                    model_composite_unique_list[constr_name],
                    'key',
                )}',transaction: t
                });`;
                res_down_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintNameOfCompositeKey(
                    table_name,
                    table_schema,
                    model_composite_unique_list[constr_name],
                    'key',
                )}', {transaction: t});`;
            }
        }
        for (const constr_name in db_unique_list) {
            if (!Object.keys(model_composite_unique_list).includes(constr_name)) {
                //model doesnt have this unique -> remove
                res_up_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${constr_name}', {transaction: t});`;
                res_down_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${db_unique_list[
                    constr_name
                ].join("','")}'],type: 'UNIQUE',name: '${constr_name}',transaction: t,});`;
            }
        }
    }

    async getStringToDropFkBeforeChanging(
        table_name: string,
        table_schema: string,
        changed_columns: string[],
        removed_fk: { [x: string]: boolean },
    ) {
        let res_up_string: {
            add_constr_string: string;
            remove_constr_string: string;
        } = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let res_down_string: {
            add_constr_string: string;
            remove_constr_string: string;
        } = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let is_fk = await this.dbService.tableToModelInfo(this.sequelize, table_schema, table_name);
        for (const field of changed_columns) {
            //если атр был изменён, сбрасываем fk для изменения
            if (
                !removed_fk[
                    JSON.stringify({
                        tableName: table_name,
                        schema: table_schema,
                        columnName: field,
                    })
                ]
            ) {
                let is_ref = this.isReferenced(
                    table_name,
                    table_schema,
                    field,
                    this.sequelize.models as { [key: string]: ModelCtor<Model<any, any>> },
                );
                if (is_ref) {
                    let ref_table = await this.dbService.tableToModelInfo(
                        this.sequelize,
                        is_ref.schema,
                        is_ref.tableName,
                    );
                    if (ref_table[is_ref.columnName].references) {
                        removed_fk[
                            JSON.stringify({
                                tableName: is_ref.tableName,
                                schema: is_ref.schema,
                                columnName: is_ref.columnName,
                            })
                        ] = true;
                        let model_ref = this.modelService.getModelReference(
                            is_ref.column.references as {
                                model: { tableName: string; schema: string } | string;
                                key: string;
                            },
                        );
                        //console.log(ref_table)
                        res_up_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${
                            is_ref.tableName
                        }', schema: '${is_ref.schema}'}, '${
                            ref_table[is_ref.columnName].fk_name
                        }', {transaction: t});`;
                        res_up_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${
                            is_ref.tableName
                        }', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${
                            is_ref.columnName
                        }'],references: { table: { tableName: '${
                            model_ref.model.tableName
                        }', schema: '${model_ref.model.schema}' },field: '${
                            model_ref.key
                        }',}, onDelete: '${ref_table[is_ref.columnName].onDelete}',onUpdate: '${
                            ref_table[is_ref.columnName].onUpdate
                        }',name: '${this.getConstraintName(
                            is_ref.tableName,
                            is_ref.schema,
                            is_ref.columnName,
                            'fkey',
                        )}',transaction: t});`;
                        res_down_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${
                            is_ref.tableName
                        }', schema: '${is_ref.schema}'}, '${this.getConstraintName(
                            is_ref.tableName,
                            is_ref.schema,
                            is_ref.columnName,
                            'fkey',
                        )}', {transaction: t});`;
                        res_down_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${
                            is_ref.tableName
                        }', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${
                            is_ref.columnName
                        }'], references: { table: { tableName: '${
                            ref_table[is_ref.columnName].references.model.tableName
                        }', schema: '${
                            ref_table[is_ref.columnName].references.model.schema
                        }'},field: '${ref_table[is_ref.columnName].references.key}',}, onDelete: '${
                            ref_table[is_ref.columnName].onDelete
                        }',onUpdate: '${ref_table[is_ref.columnName].onUpdate}',name: '${
                            ref_table[is_ref.columnName].fk_name
                        }',transaction: t});`;
                    }
                }
            }
        }
        return { res_up_string, res_down_string };
    }

    isReferenced(
        table_name: string,
        table_schema: string,
        column_name: string,
        models: {
            [key: string]: ModelCtor<Model<any, any>>;
        },
    ) {
        for (const model in models) {
            let columns = models[model].getAttributes();
            for (const attr in columns) {
                if (columns[attr].references) {
                    let curr_ref = this.modelService.getModelReference(
                        columns[attr].references as {
                            model: string | { tableName: string; schema: string };
                            key: string;
                        },
                    );
                    if (
                        curr_ref.model.schema === table_schema &&
                        curr_ref.model.tableName == table_name &&
                        curr_ref.key === column_name
                    ) {
                        if (typeof models[model].getTableName() === typeof '')
                            return {
                                columnName: attr,
                                column: columns[attr],
                                tableName: models[model].getTableName(),
                                schema: 'public',
                            };
                        else
                            return {
                                columnName: attr,
                                column: columns[attr],
                                tableName: (models[model].getTableName() as any).tableName,
                                schema: (models[model].getTableName() as any).schema,
                            };
                    }
                }
            }
        }
        return false;
    }

    async getStringOfIndexes(table_schema: string, table_name: string, sequelize: Sequelize) {
        let up_string: {
            add_index_string: string;
            remove_index_string: string;
        } = {
            add_index_string: '',
            remove_index_string: '',
        };
        let down_string: {
            add_index_string: string;
            remove_index_string: string;
        } = {
            add_index_string: '',
            remove_index_string: '',
        };
        let db_raw_indexes: { tableName: string; indexName: string; indexDef: string }[] = (
            await this.dbService.getTableIndexes(table_schema, table_name, sequelize)
        ).at(0) as { tableName: string; indexName: string; indexDef: string }[];
        let db_indexes: {
            [x: string]: { tableName: string; indexName: string; indexDef: string };
        } = {};
        let curr_constraints = (
            await sequelize.query(
                this.dbService.getColumnsConstraintsSchemaInfo(table_schema, table_name),
            )
        ).at(0) as {
            constraint_type: string;
            table_schema: string;
            constraint_name: string;
            table_name: string;
            column_name: string;
            foreign_table_schema: string;
            foreign_table_name: string;
            foreign_column_name: string;
        }[];

        for (const raw_index of db_raw_indexes) {
            db_indexes[raw_index.indexName] = raw_index;
            if (raw_index.indexName.match(/.*_pkey/)) delete db_indexes[raw_index.indexName];
            for (const constr of curr_constraints) {
                if (
                    constr.constraint_name === raw_index.indexName &&
                    constr.constraint_type === 'UNIQUE'
                )
                    delete db_indexes[raw_index.indexName];
            }
        }
        let curr_model = this.modelService.getModelByTableName(sequelize, table_name, table_schema);
        if (curr_model !== undefined) {
            let model_create_indexes_strings = this.getQueryCreateIndexString(
                table_name,
                table_schema,
                this.modelService.getModelByTableName(sequelize, table_name, table_schema),
                sequelize,
            );
            for (const model_index of curr_model.options.indexes as IndexesOptions[]) {
                let tmp_model_index = JSON.parse(JSON.stringify(model_index));
                tmp_model_index.transaction = 't';
                if (!Object.keys(db_indexes).includes(model_index.name as string)) {
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(
                        tmp_model_index,
                    ).replace(/"\btransaction":"t"/g, '"transaction": t')});`;
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    // добавляем индекс
                } else if (
                    model_create_indexes_strings[model_index.name as string].replace(
                        /\s|"/g,
                        '',
                    ) !== db_indexes[model_index.name as string].indexDef.replace(/\s|"/g, '')
                ) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(
                        tmp_model_index,
                    ).replace(/"\btransaction":"t"/g, '"transaction": t')});`;
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${
                        db_indexes[model_index.name as string].indexDef
                    }', {transaction: t});`;
                }
            }
            for (const db_index in db_indexes) {
                if (
                    !(curr_model.options.indexes as IndexesOptions[]).find(
                        (element) => element.name === db_index,
                    )
                ) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${db_index}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`;
                }
            }
        } else {
            for (const db_index in db_indexes) {
                down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`;
            }
        }
        return { up_string, down_string };
    }

    private getQueryCreateIndexString(
        table_name: string,
        table_schema: string,
        model: ModelCtor<Model<any, any>>,
        sequelize: Sequelize,
    ) {
        let index_strings: { [x: string]: string } = {};
        let model_indexes: readonly IndexesOptions[] = model.options.indexes as IndexesOptions[];
        for (const index of model_indexes) {
            index_strings[index.name as string] = '';
            index_strings[index.name as string] += `CREATE `;
            if (index.unique) index_strings[index.name as string] += `UNIQUE `;
            index_strings[
                index.name as string
            ] += `INDEX "${index.name}" ON "${table_schema}"."${table_name}" `;
            if (index.using === undefined) index_strings[index.name as string] += `USING btree (`;
            else index_strings[index.name as string] += `USING ${index.using.toLowerCase()} (`;
            if (typeof index.fields === typeof '') {
                index_strings[index.name as string] += `${index.fields})`;
            } else {
                for (const [i, field] of (
                    index.fields as {
                        name: string;
                        length?: number | undefined;
                        order?: 'ASC' | 'DESC' | undefined;
                        collate?: string | undefined;
                        operator?: string | undefined;
                    }[]
                ).entries()) {
                    let tmp_field = field as {
                        name: string;
                        length?: number | undefined;
                        order?: 'ASC' | 'DESC' | undefined;
                        collate?: string | undefined;
                        operator?: string | undefined;
                    };
                    index_strings[index.name as string] += `"${tmp_field.name}" `;
                    if (tmp_field.collate)
                        index_strings[index.name as string] += `COLLATE "${tmp_field.collate}" `;
                    if (tmp_field.operator)
                        index_strings[index.name as string] += `${tmp_field.operator} `;
                    if (tmp_field.order)
                        index_strings[index.name as string] += `${tmp_field.order} `;
                    if (i !== (index.fields?.length as number) - 1)
                        index_strings[index.name as string] += `, `;
                }
            }
            index_strings[index.name as string] += `) `;
            index_strings[index.name as string] = index_strings[index.name as string].replace(
                /\s|"/g,
                '',
            );
        }
        return index_strings;
    }

    private getConstraintNameOfCompositeKey(
        table_name: string,
        table_schema: string,
        fields: Array<string>,
        suffix: string,
    ) {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        for (const field of fields) {
            res_string += `${field}_`;
        }
        res_string += `${suffix}`;
        return res_string;
    }
    private getConstraintName(
        table_name: string,
        table_schema: string,
        column_name: string,
        suffix: string,
    ): string {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        if (suffix === 'pkey') return res_string + `${suffix}`;
        return res_string + `${column_name}_${suffix}`;
    }

    getUpStringToAddTable(
        model: ModelCtor<Model<any, any>> | undefined,
        model_schema: string | undefined,
        table_name: string,
        table_schema: string,
    ): string {
        let description = model?.getAttributes();
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        res_string += this.modelService.getModelColumnsAsString(description);
        res_string += `},{ transaction: t, schema: '${model_schema}'});`;
        return res_string;
    }

    async getDownStringToAddTable(
        sequelize: Sequelize,
        table_schema: string,
        table_name: string,
    ): Promise<string> {
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        let attributes = await this.dbService.tableToModelInfo(sequelize, table_schema, table_name);
        for (const column in attributes) {
            let options: ModelAttribute = attributes[column];
            res_string += `${column}:`;
            options.unique_name = undefined;
            options.fk_name = undefined;
            options.pk_name = undefined;
            options.foreignKey = undefined;
            options.unique = undefined;
            res_string += `${JSON.stringify(options)}, `;
            res_string = res_string.replace(
                /"\btype":"Sequelize.\b[^"]*"/g,
                `"type":${options.type}`,
            );
        }
        res_string += `},{ transaction: t, schema: '${table_schema}'});`;

        return Promise.resolve(res_string);
    }

    getUpStringToDeleteTable(
        model_schema: string | undefined,
        table_name: string,
        is_cascade: boolean,
    ) {
        if (is_cascade)
            return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ cascade: true, transaction: t });`;
        return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ transaction: t });`;
    }
}
