import { Sequelize, Model, ModelCtor } from 'sequelize-typescript';
import { ModelAttributeColumnOptions, WhereOptions } from 'sequelize';
import {
    SchemaColumns,
    SchemaColumnType,
    sqlToSeqTypes,
    TableToModel,
    ModelAttribute,
    MigrationOptions,
} from '../common/interfaces';
import { ModelService } from './model.service';
import { DbService } from './db.service';
import { IndexesOptions } from 'sequelize';
import { ModelAttributeColumnReferencesOptions } from 'sequelize';
import { FileService } from './file.service';

export class StringsGeneratorService {
    private sequelize: Sequelize;
    private migration_options: MigrationOptions | undefined;
    private dbService: DbService;
    private modelService: ModelService;
    private attrs_to_except = [
        'Model',
        'fieldName',
        '_modelAttribute',
        'field',
        '_autoGenerated',
        'values',
        'unique',
        'primaryKey',
        'name',
        'references',
        'onUpdate',
        'onDelete',
        'defaultValue',
        'pk_name',
        'fk_name',
        'unique_name'
    ];
    constructor(_sequelize: Sequelize, dbService: DbService, modelService: ModelService) {
        this.sequelize = _sequelize;
        this.dbService = dbService;
        this.modelService = modelService;
    }
    async getStringsToChangeTable(
        sequelize: Sequelize,
        table_schema: string,
        table_name: string,
        removed_fk: { [x: string]: boolean }
    ): Promise<{
        upString: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string, pk: string, unique: string };
            remove_constraints_string: { fk: string, pk: string, unique: string }
        }, downString: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string, pk: string, unique: string };
            remove_constraints_string: { fk: string, pk: string, unique: string }
        },
    }> {
        let up_string: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string, pk: string, unique: string };
            remove_constraints_string: { fk: string, pk: string, unique: string }
        } = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' }
        };
        let down_string: {
            change_column_string: string;
            add_column_string: string;
            remove_column_string: string;
            add_constraints_string: { fk: string, pk: string, unique: string };
            remove_constraints_string: { fk: string, pk: string, unique: string }
        } = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' }
        };

        let tableInDb: TableToModel = await this.dbService.tableToModelInfo(
            sequelize,
            table_schema,
            table_name,
        );
        let tableInModel = (
            this.modelService.getModelByTableName(sequelize, table_name, table_schema) as ModelCtor<
                Model<any, any>
            >
        ).getAttributes();
        const model_columns_names = this.modelService.getModelAttributesNames(tableInModel);
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                let tmp_up_string = '';
                let tmp_down_string = '';
                tmp_up_string = `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                tmp_down_string = `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                tmp_up_string += `type: ${this.modelService.getTypeByModelAttr(
                    tableInModel[column].type,
                )},`;
                tmp_down_string += `type: ${tableInDb[real_column_name].type},`;
                if (
                    this.modelService.getTypeByModelAttr(tableInModel[column].type) !==
                    tableInDb[real_column_name].type
                ) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined) model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    tmp_up_string += `allowNull: ${model_allow_null},`;
                    tmp_down_string += `allowNull: ${tableInDb[real_column_name].allowNull},`;
                    columns_different = true;
                }
                if (
                    tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement
                ) {
                    tmp_up_string += `autoIncrement: ${tableInModel[column].autoIncrement},`;
                    tmp_down_string += `autoIncrement: ${tableInDb[real_column_name].autoIncrement},`;
                    columns_different = true;
                }
                if (
                    tableInModel[column].defaultValue !== tableInDb[real_column_name].defaultValue
                ) {
                    tmp_up_string += `defaultValue: ${JSON.stringify(
                        tableInModel[column].defaultValue,
                    )},`;
                    tmp_down_string += `defaultValue: ${tableInDb[real_column_name].defaultValue},`;

                    columns_different = true;
                }

                tmp_up_string += '},{ transaction: t });';
                tmp_down_string += '},{ transaction: t});';
                if (!columns_different) {
                    tmp_up_string = '';
                    tmp_down_string = '';
                }
                else {
                    up_string.change_column_string += tmp_up_string;
                    down_string.change_column_string += tmp_down_string;
                }
            } else {
                //column is missing in Db -> add
                up_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                up_string.add_column_string += this.modelService.getModelColumnDescriptionAsString(
                    tableInModel,
                    column,
                );
                up_string.add_column_string += `{ transaction: t });`;
                down_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {transaction: t});`;
            }
        }
        //column is missing in Model -> delete
        for (const column in tableInDb) {
            if (!model_columns_names.includes(column)) {
                up_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {transaction: t});`;
                down_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {`;
                for (const column_attr in tableInDb[column]) {
                    if (!this.attrs_to_except.includes(column_attr)) {
                        down_string.add_column_string += `${column_attr}: ${tableInDb[column][column_attr as keyof object]
                            },`;
                    }
                }
                down_string.add_column_string += '},{transaction: t});';
            }
        }
        let constraints_res_strings = (await this.getStringToChangeConstraints(
            table_schema,
            table_name,
            tableInModel,
            tableInDb,
            removed_fk,
        ));

        up_string.remove_constraints_string.fk += constraints_res_strings.res_up_string.remove_constr_string.fk; //удаление ограничений
        up_string.remove_constraints_string.pk += constraints_res_strings.res_up_string.remove_constr_string.pk;
        up_string.remove_constraints_string.unique += constraints_res_strings.res_up_string.remove_constr_string.unique;
        up_string.add_constraints_string.pk += constraints_res_strings.res_up_string.add_constr_string.pk; //добавление ограничений
        up_string.add_constraints_string.unique += constraints_res_strings.res_up_string.add_constr_string.unique;
        up_string.add_constraints_string.fk += constraints_res_strings.res_up_string.add_constr_string.fk;

        //res_string.down_string += index_strings.down_string.remove_index_string; //удаление индексов
        down_string.remove_constraints_string.fk += constraints_res_strings.res_down_string.remove_constr_string.fk; //удаление ограничений
        down_string.remove_constraints_string.pk += constraints_res_strings.res_down_string.remove_constr_string.pk;
        down_string.remove_constraints_string.unique += constraints_res_strings.res_down_string.remove_constr_string.unique;
        down_string.add_constraints_string.pk += constraints_res_strings.res_down_string.add_constr_string.pk; //добавление ограничений
        down_string.add_constraints_string.unique += constraints_res_strings.res_down_string.add_constr_string.unique;
        down_string.add_constraints_string.fk += constraints_res_strings.res_down_string.add_constr_string.fk;
        return Promise.resolve({
            upString: up_string,
            downString: down_string,
        });
    }

    async getChangedColumns(sequelize: Sequelize, table_schema: string, table_name: string) {
        let tableInDb: TableToModel = await this.dbService.tableToModelInfo(
            sequelize,
            table_schema,
            table_name,
        );
        let tableInModel = (
            this.modelService.getModelByTableName(sequelize, table_name, table_schema) as ModelCtor<
                Model<any, any>
            >
        ).getAttributes();
        let different_columns: string[] = [];
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                if (
                    this.modelService.getTypeByModelAttr(tableInModel[column].type) !==
                    tableInDb[real_column_name].type
                ) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined) model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    columns_different = true;
                }
                if (
                    tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement
                ) {
                    columns_different = true;
                }
                if (
                    tableInModel[column].defaultValue !== tableInDb[real_column_name].defaultValue
                ) {
                    columns_different = true;
                }
                if (columns_different)
                    different_columns.push(column)
            }
        }

        return different_columns;
    }

    private async getStringToChangeConstraints(
        table_schema: string,
        table_name: string,
        tableInModel: {
            readonly [x: string]: ModelAttributeColumnOptions<Model<any, any>>;
        },
        tableInDb: TableToModel,
        removed_fk: { [x: string]: boolean }
    ) {
        let res_up_string: {
            add_constr_string: { pk: string, fk: string, unique: string };
            remove_constr_string: { pk: string, fk: string, unique: string };
        } = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let res_down_string: {
            add_constr_string: { pk: string, fk: string, unique: string };
            remove_constr_string: { pk: string, fk: string, unique: string };
        } = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let pk_model_fields: Array<string> = [];
        let pk_db_fields: Array<string> = [];
        let fk_model_fields: Array<string> = [];
        let fk_db_fields: Array<string> = [];
        let unique_model_fields: Array<string> = [];
        let unique_db_fields: Array<string> = [];
        let changed_columns = await this.getChangedColumns(this.sequelize, table_schema, table_name);
        //console.log(changed_columns)
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field as string;
            if (tableInModel[column].primaryKey) pk_model_fields.push(real_column_name);
            if (tableInModel[column].references) fk_model_fields.push(real_column_name);
            if (tableInModel[column].unique) unique_model_fields.push(real_column_name);
        }
        for (const column in tableInDb) {
            if (tableInDb[column].primaryKey) pk_db_fields.push(column);
            if (tableInDb[column].foreignKey) fk_db_fields.push(column);
            if (tableInDb[column].unique) unique_db_fields.push(column);
        }
        //PRIMARY KEYS
        if (pk_model_fields.length !== 0 && pk_db_fields.length === 0) {
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', {transaction: t});`;
        } else if (pk_model_fields.length === 0 && pk_db_fields.length !== 0) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[pk_db_fields[0]].pk_name
                }', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
        } else if (
            (JSON.stringify(pk_model_fields) !== JSON.stringify(pk_db_fields) || pk_model_fields.some(r => changed_columns.includes(r))) &&
            pk_model_fields[0]
        ) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[pk_db_fields[0]].pk_name
                }', {transaction: t});`;
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join(
                "','",
            )}'], name: '${this.getConstraintName(
                table_name,
                table_schema,
                '',
                'pkey',
            )}', transaction: t});`;
        }

        for (const field of fk_model_fields) {
            //если fk нету в дб -> добавляем
            if (!fk_db_fields.includes(field)) {
                let model_ref = this.modelService.getModelReference(
                    tableInModel[field].references as {
                        model: { tableName: string; schema: string } | string;
                        key: string;
                    },
                );
                res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${model_ref.model.tableName
                    }', schema: '${model_ref.model.schema}' },field: '${model_ref.key}',}, onDelete: '${tableInModel[field].onDelete
                    }',onUpdate: '${tableInModel[field].onUpdate
                    }', name: '${this.getConstraintName(
                        table_name,
                        table_schema,
                        field,
                        'fkey',
                    )}',transaction: t});`;
                res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                    table_name,
                    table_schema,
                    field,
                    'fkey',
                )}', {transaction: t});`;
            } else {

                if (((
                    JSON.stringify(
                        this.modelService.getModelReference(
                            tableInModel[field].references as {
                                model: { tableName: string; schema: string } | string;
                                key: string;
                            },
                        ),
                    ) !== JSON.stringify(tableInDb[field].references)) || (tableInModel[field].onDelete !== tableInDb[field].onDelete) || (tableInModel[field].onUpdate !== tableInDb[field].onUpdate || fk_model_fields.some(r => changed_columns.includes(r)))
                )
                ) {

                    let model_ref = this.modelService.getModelReference(
                        tableInModel[field].references as {
                            model: { tableName: string; schema: string } | string;
                            key: string;
                        },
                    );
                    res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                    res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${model_ref.model.tableName
                        }', schema: '${model_ref.model.schema}' },field: '${model_ref.key
                        }',}, onDelete: '${tableInModel[field].onDelete}',onUpdate: '${tableInModel[field].onUpdate
                        }',name: '${this.getConstraintName(
                            table_name,
                            table_schema,
                            field,
                            'fkey',
                        )}',transaction: t});`;
                    res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(
                        table_name,
                        table_schema,
                        field,
                        'fkey',
                    )}', {transaction: t});`;
                    res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'], references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}',name: '${tableInDb[field].fk_name}',transaction: t});`;
                }
            }
        }

        for (const field of fk_db_fields) {
            if (!fk_model_fields.includes(field)) {
                //no fk in model -> delete fk from db
                res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}', name: '${tableInDb[field].fk_name}', transaction: t});`;
            }
        }
        //UNIQUE
        let model_composite_unique_list: { [key: string]: Array<string> } = {};
        let db_unique_list: { [key: string]: Array<string> } = {};
        for (const field of unique_model_fields) {
            console.log(typeof tableInModel[field].unique)
            if (typeof tableInModel[field].unique === typeof {}) {
                if (
                    model_composite_unique_list[
                    (
                        tableInModel[field].unique as unknown as {
                            name: string;
                            msg: string;
                        }
                    ).name
                    ] === undefined
                )
                    model_composite_unique_list[
                        (
                            tableInModel[field].unique as unknown as {
                                name: string;
                                msg: string;
                            }
                        ).name
                    ] = [];
                model_composite_unique_list[
                    (
                        tableInModel[field].unique as unknown as {
                            name: string;
                            msg: string;
                        }
                    ).name
                ].push(field);
            } else if (typeof tableInModel[field].unique === typeof true) {
                if (
                    model_composite_unique_list[
                    this.getConstraintName(table_name, table_schema, field, 'key')
                    ] === undefined
                )
                    model_composite_unique_list[
                        this.getConstraintName(table_name, table_schema, field, 'key')
                    ] = [];
                model_composite_unique_list[
                    this.getConstraintName(table_name, table_schema, field, 'key')
                ].push(field);
            } else if (typeof tableInModel[field].unique === typeof '') {
                if (model_composite_unique_list[tableInModel[field].unique as string] === undefined)
                    model_composite_unique_list[tableInModel[field].unique as string] = [];
                model_composite_unique_list[tableInModel[field].unique as string].push(field);
            }
        }

        let keys_to_delete: Array<string> = [];
        for (const item in model_composite_unique_list) {
            if (
                model_composite_unique_list[item].length > 1 ||
                item !==
                this.getConstraintName(
                    table_name,
                    table_schema,
                    model_composite_unique_list[item][0],
                    'key',
                )
            ) {
                let tmp: Array<string> = [];
                for (const field of model_composite_unique_list[item]) {
                    tmp.push(field);
                }
                keys_to_delete.push(item);
                model_composite_unique_list[
                    this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')
                ] = [];
                for (const i of tmp) {
                    model_composite_unique_list[
                        this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')
                    ].push(i);
                }
            }
        }
        for (const i of keys_to_delete) delete model_composite_unique_list[i];

        for (const field of unique_db_fields) {
            if (db_unique_list[tableInDb[field].unique_name as string] === undefined)
                db_unique_list[tableInDb[field].unique_name as string] = [];
            db_unique_list[tableInDb[field].unique_name as string].push(field);
        }
        console.log(unique_db_fields);
        console.log(model_composite_unique_list)
        for (const constr_name in model_composite_unique_list) {
            if (!Object.keys(db_unique_list).includes(constr_name)) {
                //db doesnt have this unique -> add
                res_up_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${model_composite_unique_list[
                    constr_name
                ].join("','")}'],type: 'UNIQUE',name: '${this.getConstraintNameOfCompositeKey(
                    table_name,
                    table_schema,
                    model_composite_unique_list[constr_name],
                    'key',
                )}',transaction: t
                });`;
                res_down_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintNameOfCompositeKey(
                    table_name,
                    table_schema,
                    model_composite_unique_list[constr_name],
                    'key',
                )}', {transaction: t});`;
            }
        }
        for (const constr_name in db_unique_list) {
            if (!Object.keys(model_composite_unique_list).includes(constr_name)) {
                //model doesnt have this unique -> remove
                res_up_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${constr_name}', {transaction: t});`;
                res_down_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${db_unique_list[
                    constr_name
                ].join("','")}'],type: 'UNIQUE',name: '${constr_name}',transaction: t,});`;
            }
        }
        return Promise.resolve({ res_up_string, res_down_string });
    }

    async getStringToDropFkBeforeChanging(table_name: string, table_schema: string, changed_columns: string[]) {
        let res_up_string: {
            add_constr_string: string;
            remove_constr_string: string;
        } = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let res_down_string: {
            add_constr_string: string;
            remove_constr_string: string;
        } = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let removed_fk: { [x: string]: boolean } = {};
        let is_fk = (await this.dbService.tableToModelInfo(this.sequelize, table_schema, table_name));
        for (const field of changed_columns) { //если атр был изменён, сбрасываем fk для изменения
            let is_ref = this.isReferenced(table_name, table_schema, field, this.sequelize.models as { [key: string]: ModelCtor<Model<any, any>>; });
            if (is_ref) {
                let ref_table = await this.dbService.tableToModelInfo(this.sequelize, is_ref.schema, is_ref.tableName);
                if (ref_table[is_ref.columnName].references) {
                    removed_fk[JSON.stringify({ tableName: table_name, schema: table_schema, columnName: is_ref.columnName })] = true;
                    let model_ref = this.modelService.getModelReference(
                        is_ref.column.references as {
                            model: { tableName: string; schema: string } | string;
                            key: string;
                        },
                    );
                    //console.log(ref_table)
                    res_up_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, '${ref_table[is_ref.columnName].fk_name}', {transaction: t});`;
                    res_up_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${is_ref.columnName}'],references: { table: { tableName: '${model_ref.model.tableName
                        }', schema: '${model_ref.model.schema}' },field: '${model_ref.key
                        }',}, onDelete: '${ref_table[is_ref.columnName].onDelete}',onUpdate: '${ref_table[is_ref.columnName].onUpdate
                        }',name: '${this.getConstraintName(
                            table_name,
                            table_schema,
                            is_ref.columnName,
                            'fkey',
                        )}',transaction: t});`;
                    res_down_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, '${this.getConstraintName(
                        table_name,
                        table_schema,
                        is_ref.columnName,
                        'fkey',
                    )}', {transaction: t});`;
                    res_down_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${is_ref.columnName}'], references: { table: { tableName: '${ref_table[is_ref.columnName].references.model.tableName}', schema: '${ref_table[is_ref.columnName].references.model.schema}'},field: '${ref_table[is_ref.columnName].references.key}',}, onDelete: '${ref_table[is_ref.columnName].onDelete}',onUpdate: '${ref_table[is_ref.columnName].onUpdate}',name: '${ref_table[is_ref.columnName].fk_name}',transaction: t});`;
                }
            }

        }
        return { res_up_string, res_down_string, removed_fk }
    }

    isReferenced(table_name: string, table_schema: string, column_name: string, models: {
        [key: string]: ModelCtor<Model<any, any>>;
    }) {
        for (const model in models) {
            let columns = models[model].getAttributes();
            for (const attr in columns) {
                if (columns[attr].references) {
                    let curr_ref = this.modelService.getModelReference(columns[attr].references as { model: string | { tableName: string; schema: string; }; key: string; })
                    if (curr_ref.model.schema === table_schema && curr_ref.model.tableName == table_name && curr_ref.key === column_name) {
                        if (typeof models[model].getTableName() === typeof '')
                            return { columnName: attr, column: columns[attr], tableName: models[model].getTableName(), schema: 'public' }
                        else
                            return { columnName: attr, column: columns[attr], tableName: (models[model].getTableName() as any).tableName, schema: (models[model].getTableName() as any).schema }
                    }
                }
            }
        }
        return false;
    }

    async getStringOfIndexes(
        table_schema: string,
        table_name: string,
        sequelize: Sequelize
    ) {
        let up_string: {
            add_index_string: string;
            remove_index_string: string;
        } = {
            add_index_string: '',
            remove_index_string: '',
        };
        let down_string: {
            add_index_string: string;
            remove_index_string: string;
        } = {
            add_index_string: '',
            remove_index_string: '',
        };
        let db_raw_indexes: { tableName: string, indexName: string, indexDef: string }[] = (await this.dbService.getTableIndexes(table_schema, table_name, sequelize)).at(0) as { tableName: string, indexName: string, indexDef: string }[];
        let db_indexes: { [x: string]: { tableName: string, indexName: string, indexDef: string } } = {};
        let curr_constraints = (await sequelize.query(this.dbService.getColumnsConstraintsSchemaInfo(table_schema, table_name))).at(0) as { constraint_type: string, table_schema: string, constraint_name: string, table_name: string, column_name: string, foreign_table_schema: string, foreign_table_name: string, foreign_column_name: string }[];

        for (const raw_index of db_raw_indexes) {
            db_indexes[raw_index.indexName] = raw_index;
            if (raw_index.indexName.match(/.*_pkey/))
                delete db_indexes[raw_index.indexName];
            for (const constr of curr_constraints) {
                if (constr.constraint_name === raw_index.indexName && constr.constraint_type === 'UNIQUE')
                    delete db_indexes[raw_index.indexName];
            }
        }
        let curr_model = this.modelService.getModelByTableName(sequelize, table_name, table_schema);
        if(curr_model !== undefined) {
            let model_create_indexes_strings = this.getQueryCreateIndexString(table_name, table_schema, this.modelService.getModelByTableName(sequelize, table_name, table_schema), sequelize);
            for (const model_index of curr_model.options.indexes as IndexesOptions[]) {
                let tmp_model_index = JSON.parse(JSON.stringify(model_index));
                tmp_model_index.transaction = 't';
                if (!Object.keys(db_indexes).includes(model_index.name as string)) {
                    console.log(db_indexes)
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(tmp_model_index).replace(/"\btransaction":"t"/g, '"transaction": t')});`
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    // добавляем индекс
                }
                else if (model_create_indexes_strings[model_index.name as string].replace(/\s|"/g, "") !== db_indexes[model_index.name as string].indexDef.replace(/\s|"/g, "")) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(tmp_model_index).replace(/"\btransaction":"t"/g, '"transaction": t')});`
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[model_index.name as string].indexDef}', {transaction: t});`
                }
            }
            for (const db_index in db_indexes) {
                if (!((curr_model.options.indexes as IndexesOptions[]).find((element) => element.name === db_index))) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${db_index}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`
                }
            }
        }
        else {
            for (const db_index in db_indexes) {
                down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`
            }
        }
        return { up_string, down_string };
    }

    private getQueryCreateIndexString(table_name: string, table_schema: string, model: ModelCtor<Model<any, any>>, sequelize: Sequelize) {
        let index_strings: { [x: string]: string } = {};
        let model_indexes: readonly IndexesOptions[] = model.options.indexes as IndexesOptions[];
        for (const index of model_indexes) {
            index_strings[index.name as string] = '';
            index_strings[index.name as string] += `CREATE `;
            if (index.unique)
                index_strings[index.name as string] += `UNIQUE `;
            index_strings[index.name as string] += `INDEX "${index.name}" ON "${table_schema}"."${table_name}" `;
            if (index.using === undefined)
                index_strings[index.name as string] += `USING btree (`;
            else
                index_strings[index.name as string] += `USING ${index.using.toLowerCase()} (`;
            if (typeof index.fields === typeof '') {
                index_strings[index.name as string] += `${index.fields})`
            }
            else {
                for (const [i, field] of (index.fields as {
                    name: string;
                    length?: number | undefined;
                    order?: "ASC" | "DESC" | undefined;
                    collate?: string | undefined;
                    operator?: string | undefined;
                }[]).entries()) {
                    let tmp_field = field as {
                        name: string;
                        length?: number | undefined;
                        order?: "ASC" | "DESC" | undefined;
                        collate?: string | undefined;
                        operator?: string | undefined;
                    }
                    index_strings[index.name as string] += `"${tmp_field.name}" `;
                    if (tmp_field.collate)
                        index_strings[index.name as string] += `COLLATE "${tmp_field.collate}" `;
                    if (tmp_field.operator)
                        index_strings[index.name as string] += `${tmp_field.operator} `;
                    if (tmp_field.order)
                        index_strings[index.name as string] += `${tmp_field.order} `;
                    if (i !== index.fields?.length as number - 1)
                        index_strings[index.name as string] += `, `;
                }
            }
            index_strings[index.name as string] += `) `;
            index_strings[index.name as string] = index_strings[index.name as string].replace(/\s|"/g, "");

        }
        return index_strings;
    }

    private getConstraintNameOfCompositeKey(
        table_name: string,
        table_schema: string,
        fields: Array<string>,
        suffix: string,
    ) {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        for (const field of fields) {
            res_string += `${field}_`;
        }
        res_string += `${suffix}`;
        return res_string;
    }
    private getConstraintName(
        table_name: string,
        table_schema: string,
        column_name: string,
        suffix: string,
    ): string {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        if (suffix === 'pkey') return res_string + `${suffix}`;
        return res_string + `${column_name}_${suffix}`;
    }



    getUpStringToAddTable(
        model: ModelCtor<Model<any, any>> | undefined,
        model_schema: string | undefined,
        table_name: string,
        table_schema: string
    ): string {
        let description = model?.getAttributes();
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        res_string += this.modelService.getModelColumnsAsString(description);
        res_string += `},{ transaction: t, schema: '${model_schema}'});`;
        return res_string;
    }

    async getDownStringToAddTable(
        sequelize: Sequelize,
        table_schema: string,
        table_name: string,
    ): Promise<string> {
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        let attributes = await this.dbService.tableToModelInfo(sequelize, table_schema, table_name);
        for (const column in attributes) {
            let options: ModelAttribute = attributes[column];
            res_string += `${column}:`;
            options.unique_name = undefined;
            options.fk_name = undefined;
            options.pk_name = undefined;
            options.foreignKey = undefined;
            res_string += `${JSON.stringify(options)}, `;
            res_string = res_string.replace(
                /"\btype":"Sequelize.\b[^"]*"/g,
                `"type":${options.type}`,
            );
        }
        res_string += `},{ transaction: t, schema: '${table_schema}'});`;

        return Promise.resolve(res_string);
    }

    getUpStringToDeleteTable(model_schema: string | undefined, table_name: string, is_cascade: boolean) {
        if (is_cascade)
            return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ cascade: true, transaction: t });`;
        return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ transaction: t });`;
    }
}
