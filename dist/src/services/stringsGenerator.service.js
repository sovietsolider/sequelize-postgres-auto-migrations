"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringsGeneratorService = void 0;
class StringsGeneratorService {
    constructor(_sequelize, dbService, modelService) {
        this.attrs_to_except = [
            'Model',
            'fieldName',
            '_modelAttribute',
            'field',
            '_autoGenerated',
            'values',
            'unique',
            'primaryKey',
            'name',
            'references',
            'onUpdate',
            'onDelete',
            'defaultValue',
            'pk_name',
            'fk_name',
            'unique_name',
            'get',
            'validate',
            'comment'
        ];
        this.sequelize = _sequelize;
        this.dbService = dbService;
        this.modelService = modelService;
    }
    async getStringsToChangeTable(sequelize, table_schema, table_name, removed_fk) {
        let up_string = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' },
        };
        let down_string = {
            change_column_string: '',
            add_column_string: '',
            remove_column_string: '',
            add_constraints_string: { fk: '', pk: '', unique: '' },
            remove_constraints_string: { fk: '', pk: '', unique: '' },
        };
        let tableInDb = await this.dbService.tableToModelInfo(sequelize, table_schema, table_name);
        let tableInModel = this.modelService.getModelByTableName(sequelize, table_name, table_schema).getAttributes();
        const model_columns_names = this.modelService.getModelAttributesNames(tableInModel);
        for (const column of model_columns_names) {
            let real_column_name = tableInModel[column].field;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                let tmp_up_string = '';
                let tmp_down_string = '';
                //обработка array(enum)
                let model_type = this.modelService.getTypeByModelAttr(tableInModel[column].type, '');
                let db_type = tableInDb[real_column_name].type;
                let delete_enum_type_down_string = '';
                let delete_enum_type_up_string = '';
                let raw_type = this.getRawEnumType(tableInModel, table_name, real_column_name);
                let type_schema = `"${table_schema}".`;
                if (model_type.includes('ARRAY') && model_type.includes('ENUM')) {
                    let model_enum_values = [];
                    let db_enum_values = [];
                    this.modelService.getTypeByModelAttr(tableInModel[column].type, '', { enum_values: model_enum_values, raw_type: '' });
                    await this.dbService.tableToModelInfo(sequelize, table_schema, table_name, { enum_values: db_enum_values, column_name: real_column_name });
                    if (db_type === null || db_type === void 0 ? void 0 : db_type.includes('ENUM'))
                        tmp_up_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to "${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`;
                    tmp_up_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${model_enum_values.join("','")}')\`, {transaction: t});`;
                    tmp_up_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${column}" type ${type_schema}${raw_type} using "${column}"::text::${type_schema}${raw_type};', {transaction: t});`;
                    if (db_type === null || db_type === void 0 ? void 0 : db_type.includes('ENUM'))
                        tmp_up_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;
                    if (db_type === null || db_type === void 0 ? void 0 : db_type.includes('ENUM')) {
                        tmp_down_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to "${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${db_enum_values.join("','")}')\`, {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${real_column_name}" type ${type_schema}${raw_type} using "${column}"::text::${type_schema}${raw_type};', {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;
                    }
                    else {
                        delete_enum_type_down_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}";', {transaction: t});`;
                    }
                }
                else if ((db_type === null || db_type === void 0 ? void 0 : db_type.includes('ARRAY')) && db_type.includes('ENUM')) {
                    let model_enum_values = [];
                    let db_enum_values = [];
                    this.modelService.getTypeByModelAttr(tableInModel[column].type, '', { enum_values: model_enum_values, raw_type: '' });
                    await this.dbService.tableToModelInfo(sequelize, table_schema, table_name, { enum_values: db_enum_values, column_name: real_column_name });
                    if (model_type === null || model_type === void 0 ? void 0 : model_type.includes('ENUM'))
                        tmp_down_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to "${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`;
                    tmp_down_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${db_enum_values.join("','")}')\`, {transaction: t});`;
                    tmp_down_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${column}" type ${type_schema}${raw_type} using "${column}"::text::${type_schema}${raw_type};', {transaction: t});`;
                    if (model_type === null || model_type === void 0 ? void 0 : model_type.includes('ENUM'))
                        tmp_down_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;
                    if (model_type === null || model_type === void 0 ? void 0 : model_type.includes('ENUM')) {
                        tmp_down_string += `await queryInterface.sequelize.query('alter type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" rename to "${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old"', {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query(\`create type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}" as enum ('${model_enum_values.join("','")}')\`, {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query('alter table "${table_schema}"."${table_name}" alter column "${real_column_name}" type ${type_schema}${raw_type} using "${column}"::text::${type_schema}${raw_type};', {transaction: t});`;
                        tmp_down_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}_old";', {transaction: t});`;
                    }
                    else {
                        delete_enum_type_up_string += `await queryInterface.sequelize.query('drop type ${type_schema}"${raw_type.replace('[]', '').replace(/['"]+/g, '')}";', {transaction: t});`;
                    }
                }
                tmp_up_string += `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                tmp_down_string += `await queryInterface.changeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                if ((model_type === null || model_type === void 0 ? void 0 : model_type.includes('ARRAY')) && (model_type === null || model_type === void 0 ? void 0 : model_type.includes('ENUM'))) {
                    tmp_up_string += `type: '${type_schema}${raw_type}',`;
                    if (db_type === null || db_type === void 0 ? void 0 : db_type.includes('ENUM'))
                        tmp_down_string += `type: '${type_schema}${raw_type}',`;
                    else
                        tmp_down_string += `type: ${tableInDb[real_column_name].type},`;
                }
                else if ((db_type === null || db_type === void 0 ? void 0 : db_type.includes('ARRAY')) && (db_type === null || db_type === void 0 ? void 0 : db_type.includes('ENUM'))) {
                    tmp_down_string += `type: '${type_schema}${raw_type}',`;
                    if (model_type === null || model_type === void 0 ? void 0 : model_type.includes('ENUM'))
                        tmp_up_string += `type: '${type_schema}${raw_type}',`;
                    else
                        tmp_up_string += `type: ${model_type},`;
                }
                else if (model_type === 'Sequelize.INTEGER'
                    && tableInDb[real_column_name].type !== 'Sequelize.INTEGER') {
                    tmp_up_string += `type: 'INTEGER USING CAST ("${real_column_name}" as INTEGER)',`;
                }
                else {
                    tmp_up_string += `type: ${this.modelService.getTypeByModelAttr(tableInModel[column].type)},`;
                    tmp_down_string += `type: ${tableInDb[real_column_name].type},`;
                }
                if (model_type !==
                    tableInDb[real_column_name].type) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined)
                    model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    tmp_up_string += `allowNull: ${model_allow_null},`;
                    tmp_down_string += `allowNull: ${tableInDb[real_column_name].allowNull},`;
                    columns_different = true;
                }
                if (tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement) {
                    tmp_up_string += `autoIncrement: ${tableInModel[column].autoIncrement},`;
                    tmp_down_string += `autoIncrement: ${tableInDb[real_column_name].autoIncrement},`;
                    columns_different = true;
                }
                if ((tableInModel[column].defaultValue + '') !== (tableInDb[real_column_name].defaultValue + '')) {
                    tmp_up_string += `defaultValue: ${JSON.stringify(tableInModel[column].defaultValue)},`;
                    tmp_down_string += `defaultValue: ${tableInDb[real_column_name].defaultValue},`;
                    columns_different = true;
                }
                //console.log(tableInModel[column].comment, tableInDb[real_column_name].comment);
                if (tableInModel[column].comment !== tableInDb[real_column_name].comment) {
                    if (tableInModel[column].comment)
                        tmp_up_string += `comment: '${tableInModel[column].comment}',`;
                    else
                        tmp_up_string += `comment: ${tableInModel[column].comment},`;
                    if (tableInDb[real_column_name].comment)
                        tmp_down_string += `comment: '${tableInDb[real_column_name].comment}',`;
                    else
                        tmp_down_string += `comment: ${tableInDb[real_column_name].comment},`;
                    columns_different = true;
                }
                if (columns_different && model_allow_null === tableInDb[real_column_name].allowNull) { //sequelize drop allow null
                    tmp_up_string += `allowNull: ${model_allow_null},`;
                    tmp_down_string += `allowNull: ${tableInDb[real_column_name].allowNull},`;
                }
                tmp_up_string += '},{ transaction: t });';
                tmp_down_string += '},{ transaction: t});';
                tmp_down_string += delete_enum_type_down_string;
                tmp_up_string += delete_enum_type_up_string;
                if (!columns_different) {
                    tmp_up_string = '';
                    tmp_down_string = '';
                }
                else {
                    up_string.change_column_string += tmp_up_string;
                    down_string.change_column_string += tmp_down_string;
                }
            }
            else {
                //column is missing in Db -> add
                up_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {`;
                up_string.add_column_string += this.modelService.getModelColumnDescriptionAsString(tableInModel, column);
                up_string.add_column_string += `{ transaction: t });`;
                down_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${real_column_name}', {transaction: t});`;
            }
        }
        //column is missing in Model -> delete
        for (const column in tableInDb) {
            if (!model_columns_names.includes(column)) {
                up_string.remove_column_string += `await queryInterface.removeColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {transaction: t});`;
                down_string.add_column_string += `await queryInterface.addColumn({tableName: '${table_name}', schema: '${table_schema}'}, '${column}', {`;
                for (const column_attr in tableInDb[column]) {
                    if (!this.attrs_to_except.includes(column_attr)) {
                        down_string.add_column_string += `${column_attr}: ${tableInDb[column][column_attr]},`;
                    }
                }
                down_string.add_column_string += '},{transaction: t});';
            }
        }
        let constraints_res_strings = await this.getStringToChangeConstraints(table_schema, table_name, tableInModel, tableInDb, removed_fk);
        up_string.remove_constraints_string.fk +=
            constraints_res_strings.res_up_string.remove_constr_string.fk; //удаление ограничений
        up_string.remove_constraints_string.pk +=
            constraints_res_strings.res_up_string.remove_constr_string.pk;
        up_string.remove_constraints_string.unique +=
            constraints_res_strings.res_up_string.remove_constr_string.unique;
        up_string.add_constraints_string.pk +=
            constraints_res_strings.res_up_string.add_constr_string.pk; //добавление ограничений
        up_string.add_constraints_string.unique +=
            constraints_res_strings.res_up_string.add_constr_string.unique;
        up_string.add_constraints_string.fk +=
            constraints_res_strings.res_up_string.add_constr_string.fk;
        //res_string.down_string += index_strings.down_string.remove_index_string; //удаление индексов
        down_string.remove_constraints_string.fk +=
            constraints_res_strings.res_down_string.remove_constr_string.fk; //удаление ограничений
        down_string.remove_constraints_string.pk +=
            constraints_res_strings.res_down_string.remove_constr_string.pk;
        down_string.remove_constraints_string.unique +=
            constraints_res_strings.res_down_string.remove_constr_string.unique;
        down_string.add_constraints_string.pk +=
            constraints_res_strings.res_down_string.add_constr_string.pk; //добавление ограничений
        down_string.add_constraints_string.unique +=
            constraints_res_strings.res_down_string.add_constr_string.unique;
        down_string.add_constraints_string.fk +=
            constraints_res_strings.res_down_string.add_constr_string.fk;
        return Promise.resolve({
            upString: up_string,
            downString: down_string,
        });
    }
    getRawEnumType(tableInModel, table_name, column_name) {
        var _a;
        let depth_count = (_a = this.modelService.getTypeByModelAttr(tableInModel[column_name].type, '').match(/ARRAY/)) === null || _a === void 0 ? void 0 : _a.length;
        let raw_type_depth = '';
        for (let i = 0; i < depth_count; i++)
            raw_type_depth += '[]';
        return `"enum_${table_name}_${column_name}"${raw_type_depth}`;
    }
    async getChangedColumns(sequelize, table_schema, table_name) {
        let tableInDb = await this.dbService.tableToModelInfo(sequelize, table_schema, table_name);
        let tableInModel = this.modelService.getModelByTableName(sequelize, table_name, table_schema).getAttributes();
        let different_columns = [];
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field;
            if (Object.keys(tableInDb).includes(real_column_name)) {
                let columns_different = false;
                if (this.modelService.getTypeByModelAttr(tableInModel[column].type) !==
                    tableInDb[real_column_name].type) {
                    columns_different = true;
                }
                let model_allow_null = tableInModel[column].allowNull;
                if (tableInModel[column].primaryKey || tableInModel[column].autoIncrement) {
                    model_allow_null = false;
                }
                if (model_allow_null === undefined)
                    model_allow_null = true;
                if (model_allow_null !== tableInDb[real_column_name].allowNull) {
                    columns_different = true;
                }
                if (tableInModel[column].autoIncrement !== tableInDb[real_column_name].autoIncrement) {
                    columns_different = true;
                }
                if (tableInModel[column].defaultValue !== tableInDb[real_column_name].defaultValue) {
                    columns_different = true;
                }
                if (columns_different)
                    different_columns.push(column);
            }
        }
        return different_columns;
    }
    async getStringToChangeConstraints(table_schema, table_name, tableInModel, tableInDb, removed_fk) {
        var _a, _b, _c, _d;
        let res_up_string = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let res_down_string = {
            add_constr_string: { pk: '', fk: '', unique: '' },
            remove_constr_string: { pk: '', fk: '', unique: '' },
        };
        let pk_model_fields = [];
        let pk_db_fields = [];
        let fk_model_fields = [];
        let fk_db_fields = [];
        let unique_model_fields = [];
        let unique_db_fields = [];
        let changed_columns = await this.getChangedColumns(this.sequelize, table_schema, table_name);
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field;
            if (tableInModel[column].primaryKey)
                pk_model_fields.push(real_column_name);
            if (tableInModel[column].references)
                fk_model_fields.push(real_column_name);
            if (tableInModel[column].unique)
                unique_model_fields.push(real_column_name);
        }
        for (const column in tableInDb) {
            if (tableInDb[column].primaryKey)
                pk_db_fields.push(column);
            if (tableInDb[column].foreignKey)
                fk_db_fields.push(column);
            if (tableInDb[column].unique)
                unique_db_fields.push(column);
        }
        //PRIMARY KEYS
        if (pk_model_fields.length !== 0 && pk_db_fields.length === 0) {
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join("','")}'], name: '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', {transaction: t});`;
        }
        else if (pk_model_fields.length === 0 && pk_db_fields.length !== 0) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[pk_db_fields[0]].pk_name}', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join("','")}'], name: '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', transaction: t});`;
        }
        else if ((JSON.stringify(pk_model_fields) !== JSON.stringify(pk_db_fields) ||
            pk_model_fields.some((r) => changed_columns.includes(r))) &&
            pk_model_fields[0]) {
            res_up_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[pk_db_fields[0]].pk_name}', {transaction: t});`;
            res_up_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields: ['${pk_model_fields.join("','")}'], name: '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', transaction: t});`;
            res_down_string.remove_constr_string.pk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', {transaction: t});`;
            res_down_string.add_constr_string.pk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'PRIMARY KEY', fields:['${pk_db_fields.join("','")}'], name: '${this.getConstraintName(table_name, table_schema, '', 'pkey')}', transaction: t});`;
        }
        for (const field of fk_model_fields) {
            //если fk нету в дб -> добавляем
            if (!fk_db_fields.includes(field)) {
                let model_ref = this.modelService.getModelReference(tableInModel[field].references);
                res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${model_ref.model.tableName}', schema: '${model_ref.model.schema}' },field: '${model_ref.key}',}, onDelete: '${tableInModel[field].onDelete}',onUpdate: '${tableInModel[field].onUpdate}', name: '${this.getConstraintName(table_name, table_schema, field, 'fkey')}',transaction: t});`;
                res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(table_name, table_schema, field, 'fkey')}', {transaction: t});`;
            }
            else {
                if (((JSON.stringify(this.modelService.getModelReference(tableInModel[field].references)) !== JSON.stringify(tableInDb[field].references)) ||
                    ((_a = tableInModel[field].onDelete) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== ((_b = tableInDb[field].onDelete) === null || _b === void 0 ? void 0 : _b.toLowerCase()) ||
                    ((_c = tableInModel[field].onUpdate) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== ((_d = tableInDb[field].onUpdate) === null || _d === void 0 ? void 0 : _d.toLowerCase()) ||
                    fk_model_fields.some((r) => changed_columns.includes(r))) &&
                    //|| changed_columns.some(r => this.isReferenced(table_name, table_schema, r, this.sequelize.models as { [key: string]: ModelCtor<Model<any, any>>; }))
                    !removed_fk[JSON.stringify({
                        tableName: table_name,
                        schema: table_schema,
                        columnName: field,
                    })]) {
                    /*console.log(
                        this.modelService.getModelReference(
                            tableInModel[field].references as {
                                model: { tableName: string; schema: string } | string;
                                key: string;
                            },
                        ));
                    console.log(tableInDb[field].references)*/
                    let model_ref = this.modelService.getModelReference(tableInModel[field].references);
                    res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                    res_up_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${model_ref.model.tableName}', schema: '${model_ref.model.schema}' },field: '${model_ref.key}',}, onDelete: '${tableInModel[field].onDelete}',onUpdate: '${tableInModel[field].onUpdate}',name: '${this.getConstraintName(table_name, table_schema, field, 'fkey')}',transaction: t});`;
                    res_down_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintName(table_name, table_schema, field, 'fkey')}', {transaction: t});`;
                    res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'], references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}',name: '${tableInDb[field].fk_name}',transaction: t});`;
                }
            }
        }
        for (const field of fk_db_fields) {
            if (!fk_model_fields.includes(field)) {
                //no fk in model -> delete fk from db
                res_up_string.remove_constr_string.fk += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${tableInDb[field].fk_name}', {transaction: t});`;
                res_down_string.add_constr_string.fk += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, { type: 'FOREIGN KEY', fields: ['${field}'],references: { table: { tableName: '${tableInDb[field].references.model.tableName}', schema: '${tableInDb[field].references.model.schema}'},field: '${tableInDb[field].references.key}',}, onDelete: '${tableInDb[field].onDelete}',onUpdate: '${tableInDb[field].onUpdate}', name: '${tableInDb[field].fk_name}', transaction: t});`;
            }
        }
        //UNIQUE
        this.getStringToCompareUniqueConstraints(table_name, table_schema, tableInModel, res_up_string, res_down_string, tableInDb);
        return Promise.resolve({ res_up_string, res_down_string });
    }
    getStringToCompareUniqueConstraints(table_name, table_schema, tableInModel, res_up_string, res_down_string, tableInDb = {}) {
        let model_composite_unique_list = {};
        let db_unique_list = {};
        let unique_model_fields = [];
        let unique_db_fields = [];
        //if(tableInModel === undefined)
        //    tableInModel = {};
        for (const column in tableInModel) {
            let real_column_name = tableInModel[column].field;
            if (tableInModel[column].unique)
                unique_model_fields.push(real_column_name);
        }
        for (const column in tableInDb) {
            if (tableInDb[column].unique)
                unique_db_fields.push(column);
        }
        for (const field of unique_model_fields) {
            if (typeof tableInModel[field].unique === typeof {}) {
                if (model_composite_unique_list[tableInModel[field].unique.name] === undefined)
                    model_composite_unique_list[tableInModel[field].unique.name] = [];
                model_composite_unique_list[tableInModel[field].unique.name].push(field);
            }
            else if (typeof tableInModel[field].unique === typeof true) {
                if (model_composite_unique_list[this.getConstraintName(table_name, table_schema, field, 'key')] === undefined)
                    model_composite_unique_list[this.getConstraintName(table_name, table_schema, field, 'key')] = [];
                model_composite_unique_list[this.getConstraintName(table_name, table_schema, field, 'key')].push(field);
            }
            else if (typeof tableInModel[field].unique === typeof '') {
                if (model_composite_unique_list[tableInModel[field].unique] === undefined)
                    model_composite_unique_list[tableInModel[field].unique] = [];
                model_composite_unique_list[tableInModel[field].unique].push(field);
            }
        }
        let keys_to_delete = [];
        for (const item in model_composite_unique_list) {
            if (model_composite_unique_list[item].length > 1 ||
                item !==
                    this.getConstraintName(table_name, table_schema, model_composite_unique_list[item][0], 'key')) {
                let tmp = [];
                for (const field of model_composite_unique_list[item]) {
                    tmp.push(field);
                }
                keys_to_delete.push(item);
                model_composite_unique_list[this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')] = [];
                for (const i of tmp) {
                    model_composite_unique_list[this.getConstraintNameOfCompositeKey(table_name, table_schema, tmp, 'key')].push(i);
                }
            }
        }
        for (const i of keys_to_delete)
            delete model_composite_unique_list[i];
        for (const field of unique_db_fields) {
            if (db_unique_list[tableInDb[field].unique_name] === undefined)
                db_unique_list[tableInDb[field].unique_name] = [];
            db_unique_list[tableInDb[field].unique_name].push(field);
        }
        for (const constr_name in model_composite_unique_list) {
            if (!Object.keys(db_unique_list).includes(constr_name)) {
                //db doesnt have this unique -> add
                res_up_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${model_composite_unique_list[constr_name].join("','")}'],type: 'UNIQUE',name: '${this.getConstraintNameOfCompositeKey(table_name, table_schema, model_composite_unique_list[constr_name], 'key')}',transaction: t
                });`;
                res_down_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${this.getConstraintNameOfCompositeKey(table_name, table_schema, model_composite_unique_list[constr_name], 'key')}', {transaction: t});`;
            }
        }
        for (const constr_name in db_unique_list) {
            if (!Object.keys(model_composite_unique_list).includes(constr_name)) {
                //model doesnt have this unique -> remove
                res_up_string.remove_constr_string.unique += `await queryInterface.removeConstraint({tableName: '${table_name}', schema: '${table_schema}'}, '${constr_name}', {transaction: t});`;
                res_down_string.add_constr_string.unique += `await queryInterface.addConstraint({tableName: '${table_name}', schema: '${table_schema}'}, {fields: ['${db_unique_list[constr_name].join("','")}'],type: 'UNIQUE',name: '${constr_name}',transaction: t,});`;
            }
        }
    }
    async getStringToDropFkBeforeChanging(table_name, table_schema, changed_columns, removed_fk) {
        let res_up_string = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let res_down_string = {
            add_constr_string: '',
            remove_constr_string: '',
        };
        let is_fk = await this.dbService.tableToModelInfo(this.sequelize, table_schema, table_name);
        for (const field of changed_columns) {
            //если атр был изменён, сбрасываем fk для изменения
            if (!removed_fk[JSON.stringify({
                tableName: table_name,
                schema: table_schema,
                columnName: field,
            })]) {
                let is_ref = this.isReferenced(table_name, table_schema, field, this.sequelize.models);
                if (is_ref) {
                    let ref_table = await this.dbService.tableToModelInfo(this.sequelize, is_ref.schema, is_ref.tableName);
                    if (ref_table[is_ref.columnName].references) {
                        removed_fk[JSON.stringify({
                            tableName: is_ref.tableName,
                            schema: is_ref.schema,
                            columnName: is_ref.columnName,
                        })] = true;
                        let model_ref = this.modelService.getModelReference(is_ref.column.references);
                        //console.log(ref_table)
                        res_up_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, '${ref_table[is_ref.columnName].fk_name}', {transaction: t});`;
                        res_up_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${is_ref.columnName}'],references: { table: { tableName: '${model_ref.model.tableName}', schema: '${model_ref.model.schema}' },field: '${model_ref.key}',}, onDelete: '${ref_table[is_ref.columnName].onDelete}',onUpdate: '${ref_table[is_ref.columnName].onUpdate}',name: '${this.getConstraintName(is_ref.tableName, is_ref.schema, is_ref.columnName, 'fkey')}',transaction: t});`;
                        res_down_string.remove_constr_string += `await queryInterface.removeConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, '${this.getConstraintName(is_ref.tableName, is_ref.schema, is_ref.columnName, 'fkey')}', {transaction: t});`;
                        res_down_string.add_constr_string += `await queryInterface.addConstraint({tableName: '${is_ref.tableName}', schema: '${is_ref.schema}'}, { type: 'FOREIGN KEY', fields: ['${is_ref.columnName}'], references: { table: { tableName: '${ref_table[is_ref.columnName].references.model.tableName}', schema: '${ref_table[is_ref.columnName].references.model.schema}'},field: '${ref_table[is_ref.columnName].references.key}',}, onDelete: '${ref_table[is_ref.columnName].onDelete}',onUpdate: '${ref_table[is_ref.columnName].onUpdate}',name: '${ref_table[is_ref.columnName].fk_name}',transaction: t});`;
                    }
                }
            }
        }
        return { res_up_string, res_down_string };
    }
    isReferenced(table_name, table_schema, column_name, models) {
        for (const model in models) {
            let columns = models[model].getAttributes();
            for (const attr in columns) {
                if (columns[attr].references) {
                    let curr_ref = this.modelService.getModelReference(columns[attr].references);
                    if (curr_ref.model.schema === table_schema &&
                        curr_ref.model.tableName == table_name &&
                        curr_ref.key === column_name) {
                        if (typeof models[model].getTableName() === typeof '')
                            return {
                                columnName: attr,
                                column: columns[attr],
                                tableName: models[model].getTableName(),
                                schema: 'public',
                            };
                        else
                            return {
                                columnName: attr,
                                column: columns[attr],
                                tableName: models[model].getTableName().tableName,
                                schema: models[model].getTableName().schema,
                            };
                    }
                }
            }
        }
        return false;
    }
    async getStringOfIndexes(table_schema, table_name, sequelize) {
        let up_string = {
            add_index_string: '',
            remove_index_string: '',
        };
        let down_string = {
            add_index_string: '',
            remove_index_string: '',
        };
        let db_raw_indexes = (await this.dbService.getTableIndexes(table_schema, table_name, sequelize)).at(0);
        let db_indexes = {};
        let curr_constraints = (await sequelize.query(this.dbService.getColumnsConstraintsSchemaInfo(table_schema, table_name))).at(0);
        for (const raw_index of db_raw_indexes) {
            db_indexes[raw_index.indexName] = raw_index;
            if (raw_index.indexName.match(/.*_pkey/))
                delete db_indexes[raw_index.indexName];
            for (const constr of curr_constraints) {
                if (constr.constraint_name === raw_index.indexName &&
                    constr.constraint_type === 'UNIQUE')
                    delete db_indexes[raw_index.indexName];
            }
        }
        let curr_model = this.modelService.getModelByTableName(sequelize, table_name, table_schema);
        if (curr_model !== undefined) {
            let model_create_indexes_strings = this.getQueryCreateIndexString(table_name, table_schema, this.modelService.getModelByTableName(sequelize, table_name, table_schema), sequelize);
            for (const model_index of curr_model.options.indexes) {
                let tmp_model_index = JSON.parse(JSON.stringify(model_index));
                tmp_model_index.transaction = 't';
                if (!Object.keys(db_indexes).includes(model_index.name)) {
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(tmp_model_index).replace(/"\btransaction":"t"/g, '"transaction": t')});`;
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    // добавляем индекс
                }
                else if (model_create_indexes_strings[model_index.name].replace(/\s|"/g, '') !== db_indexes[model_index.name].indexDef.replace(/\s|"/g, '')) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    up_string.add_index_string += `await queryInterface.addIndex({tableName: '${table_name}', schema: '${table_schema}'}, ${JSON.stringify(tmp_model_index).replace(/"\btransaction":"t"/g, '"transaction": t')});`;
                    down_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${model_index.name}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[model_index.name].indexDef}', {transaction: t});`;
                }
            }
            for (const db_index in db_indexes) {
                if (!curr_model.options.indexes.find((element) => element.name === db_index)) {
                    up_string.remove_index_string += `await queryInterface.removeIndex({tableName: '${table_name}', schema: '${table_schema}'}, '${db_index}', { transaction: t });`;
                    down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`;
                }
            }
        }
        else {
            for (const db_index in db_indexes) {
                down_string.add_index_string += `await queryInterface.sequelize.query('${db_indexes[db_index].indexDef}', {transaction: t});`;
            }
        }
        return { up_string, down_string };
    }
    getQueryCreateIndexString(table_name, table_schema, model, sequelize) {
        var _a;
        let index_strings = {};
        let model_indexes = model.options.indexes;
        for (const index of model_indexes) {
            index_strings[index.name] = '';
            index_strings[index.name] += `CREATE `;
            if (index.unique)
                index_strings[index.name] += `UNIQUE `;
            index_strings[index.name] += `INDEX "${index.name}" ON "${table_schema}"."${table_name}" `;
            if (index.using === undefined)
                index_strings[index.name] += `USING btree (`;
            else
                index_strings[index.name] += `USING ${index.using.toLowerCase()} (`;
            if (typeof index.fields === typeof '') {
                index_strings[index.name] += `${index.fields})`;
            }
            else {
                for (const [i, field] of index.fields.entries()) {
                    let tmp_field = field;
                    index_strings[index.name] += `"${tmp_field.name}" `;
                    if (tmp_field.collate)
                        index_strings[index.name] += `COLLATE "${tmp_field.collate}" `;
                    if (tmp_field.operator)
                        index_strings[index.name] += `${tmp_field.operator} `;
                    if (tmp_field.order)
                        index_strings[index.name] += `${tmp_field.order} `;
                    if (i !== ((_a = index.fields) === null || _a === void 0 ? void 0 : _a.length) - 1)
                        index_strings[index.name] += `, `;
                }
            }
            index_strings[index.name] += `) `;
            index_strings[index.name] = index_strings[index.name].replace(/\s|"/g, '');
        }
        return index_strings;
    }
    getConstraintNameOfCompositeKey(table_name, table_schema, fields, suffix) {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        for (const field of fields) {
            res_string += `${field}_`;
        }
        res_string += `${suffix}`;
        return res_string;
    }
    getConstraintName(table_name, table_schema, column_name, suffix) {
        let res_string = '';
        //if(table_schema === 'public')
        res_string = `${table_name}_`;
        //else
        //    res_string = `${table_schema}.${table_name}_`
        if (suffix === 'pkey')
            return res_string + `${suffix}`;
        return res_string + `${column_name}_${suffix}`;
    }
    getUpStringToAddTable(model, model_schema, table_name, table_schema) {
        let description = model === null || model === void 0 ? void 0 : model.getAttributes();
        //console.log(model)
        //console.log(description)
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        res_string += this.modelService.getModelColumnsAsString(description);
        res_string += `},{ transaction: t, schema: '${model_schema}'});`;
        return res_string;
    }
    async getDownStringToAddTable(sequelize, table_schema, table_name) {
        let res_string = `await queryInterface.createTable({tableName: '${table_name}', schema: '${table_schema}'},{`;
        let attributes = await this.dbService.tableToModelInfo(sequelize, table_schema, table_name);
        for (const column in attributes) {
            let options = attributes[column];
            res_string += `${column}:`;
            options.unique_name = undefined;
            options.fk_name = undefined;
            options.pk_name = undefined;
            options.foreignKey = undefined;
            options.unique = undefined;
            res_string += `${JSON.stringify(options)}, `;
            res_string = res_string.replace(/"\btype":"Sequelize.\b[^"]*"/g, `"type":${options.type}`);
        }
        res_string += `},{ transaction: t, schema: '${table_schema}'});`;
        return Promise.resolve(res_string);
    }
    getUpStringToDeleteTable(model_schema, table_name, is_cascade) {
        if (is_cascade)
            return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ cascade: true, transaction: t });`;
        return `await queryInterface.dropTable({ tableName: '${table_name}', schema: '${model_schema}'},{ transaction: t });`;
    }
}
exports.StringsGeneratorService = StringsGeneratorService;
//# sourceMappingURL=stringsGenerator.service.js.map